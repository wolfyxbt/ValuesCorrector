<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä»·å€¼è§‚çº æ­£å™¨</title>
    
    <!-- Favicon å®Œæ•´æ”¯æŒ -->
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="favicon/site.webmanifest">
    <link rel="icon" type="image/x-icon" href="favicon/favicon.ico">
    <link rel="shortcut icon" type="image/x-icon" href="favicon/favicon.ico">
	    <meta name="theme-color" content="#ffffff">
    
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="ä»·å€¼è§‚çº æ­£å™¨">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XEZ049M5R2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-XEZ049M5R2');
    </script>
    
	    <style>
		        :root {
		            --bg: #ffffff;
		            --surface: #ffffff;
		            --surface-muted: #f5f5f7;
		            --text: #1d1d1f;
		            --muted: #6e6e73;
		            --border: #d2d2d7;
		            --shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
		            --focus: rgba(0, 0, 0, 0.18);
		            --unit-select-width: 240px;
		        }
	        
	        body {
	            font-family: "PingFang SC";
	            margin: 0;
	            padding: 0;
	            min-height: 100vh;
	            display: flex;
	            flex-direction: column;
	            align-items: center;
	            justify-content: center;
	            background: var(--bg);
	            color: var(--text);
	        }
        
        * {
            font-family: "PingFang SC";
        }
        
	        .container {
	            padding: 50px 50px 30px 50px;
	            text-align: center;
	            transform: scale(1.3);
	            background: var(--surface);
	            border-radius: 20px;
	            box-shadow: var(--shadow);
	            border: 1px solid var(--border);
	        }
        
	        .field {
	            margin: 20px 0;
	            display: flex;
	            align-items: center;
	            justify-content: center;
	            gap: 15px;
	        }
	        
		        .select-wrapper {
		            position: relative;
		            display: inline-block;
		            flex-shrink: 0;
		            width: var(--unit-select-width);
		        }

	        /* è‡ªå®šä¹‰ä¸‹æ‹‰ï¼ˆæ›¿ä»£ç³»ç»Ÿ selectï¼‰ */
	        .native-select-hidden {
	            position: absolute !important;
	            inset: 0 !important;
	            opacity: 0 !important;
	            pointer-events: none !important;
	        }

		        .dropdown {
		            position: relative;
		            width: 100%;
		            min-width: 0;
		        }

	        .dropdown-trigger {
	            width: 100%;
	            display: flex;
	            align-items: center;
	            justify-content: space-between;
	            gap: 10px;
	            padding: 15px 45px 15px 20px;
	            font-size: 16px;
	            border: 1px solid var(--border);
	            border-radius: 12px;
	            background: var(--surface);
	            color: var(--text);
	            cursor: pointer;
	            user-select: none;
	            transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
	            box-sizing: border-box;
	        }

	        .dropdown-trigger:hover {
	            border-color: var(--text);
	            background: var(--surface-muted);
	        }

	        .dropdown-trigger:focus {
	            outline: none;
	            border-color: var(--text);
	            box-shadow: 0 0 0 3px var(--focus);
	        }

		        .dropdown-trigger-left {
		            display: flex;
		            align-items: center;
		            gap: 10px;
		            overflow: hidden;
		            min-width: 0;
		        }

		        .dropdown-logo {
		            width: 22px;
		            height: 22px;
		            border-radius: 50%;
		            overflow: hidden;
		            display: flex;
		            align-items: center;
		            justify-content: center;
		            background: var(--surface-muted);
		            border: 1px solid var(--border);
		            flex-shrink: 0;
		        }
		        
		        /* Emoji å›¾æ ‡ï¼šå»é™¤åœ†æ¡†ï¼Œä»…ä¿ç•™å†…å®¹æœ¬èº«ï¼ˆç”¨äºé€‰æ‹©æ¡†/ä¸‹æ‹‰èœå•ï¼‰ */
		        .dropdown-logo.is-emoji {
		            background: transparent;
		            border: none;
		            border-radius: 0;
		        }

		        .dropdown-logo.is-emoji .dropdown-logo-emoji {
		            font-size: 18px;
		            line-height: 1;
		        }

	        .dropdown-logo img {
	            width: 100%;
	            height: 100%;
	            object-fit: cover;
	            display: block;
	        }

	        .dropdown-logo-emoji {
	            font-size: 14px;
	            line-height: 1;
	        }

		        .dropdown-text {
		            white-space: nowrap;
		            overflow: hidden;
		            text-overflow: ellipsis;
		            min-width: 0;
		        }

	        .dropdown-chevron {
	            width: 16px;
	            height: 16px;
	            flex-shrink: 0;
	            opacity: 0.85;
	        }

	        .dropdown-menu {
	            position: fixed;
	            left: 0;
	            top: 0;
	            width: 300px;
	            overflow: visible; /* å…è®¸ç®­å¤´è¶…å‡ºè¾¹ç•Œ */
	            background: var(--surface);
	            border: 1px solid var(--border);
	            border-radius: 14px;
	            box-shadow: var(--shadow);
	            z-index: 9999;
	            display: none;
	        }
	        
	        .dropdown-menu-scroll {
	            max-height: 680px;
	            overflow: auto;
	            padding: 8px;
	            border-radius: 14px;
	        }
	        
	        /* ä¸‹æ‹‰èœå•ç®­å¤´ï¼ˆæŒ‡å‘ç›®æ ‡æ¡†ï¼‰ */
	        .dropdown-menu::before,
	        .dropdown-menu::after {
	            content: "";
	            position: absolute;
	            width: 0;
	            height: 0;
	            top: calc(var(--arrow-top, 28px) - 9px);
	        }
	        
	        /* é»˜è®¤ï¼šèœå•åœ¨ç›®æ ‡æ¡†å³ä¾§ï¼Œç®­å¤´åœ¨å·¦è¾¹æŒ‡å‘ç›®æ ‡æ¡† */
	        .dropdown-menu[data-side="right"]::before {
	            left: -10px;
	            border-top: 9px solid transparent;
	            border-bottom: 9px solid transparent;
	            border-right: 10px solid var(--border);
	        }
	        
	        .dropdown-menu[data-side="right"]::after {
	            left: -9px;
	            border-top: 8px solid transparent;
	            border-bottom: 8px solid transparent;
	            border-right: 9px solid var(--surface);
	            top: calc(var(--arrow-top, 28px) - 8px);
	        }
	        
	        /* ç¿»è½¬ï¼šèœå•åœ¨ç›®æ ‡æ¡†å·¦ä¾§ï¼Œç®­å¤´åœ¨å³è¾¹æŒ‡å‘ç›®æ ‡æ¡† */
	        .dropdown-menu[data-side="left"]::before {
	            right: -10px;
	            border-top: 9px solid transparent;
	            border-bottom: 9px solid transparent;
	            border-left: 10px solid var(--border);
	        }
	        
	        .dropdown-menu[data-side="left"]::after {
	            right: -9px;
	            border-top: 8px solid transparent;
	            border-bottom: 8px solid transparent;
	            border-left: 9px solid var(--surface);
	            top: calc(var(--arrow-top, 28px) - 8px);
	        }

	        .dropdown-group {
	            padding: 8px 10px 6px 10px;
	            color: var(--muted);
	            font-size: 12px;
	            letter-spacing: 0.02em;
	        }

	        .dropdown-item {
	            display: flex;
	            align-items: center;
	            gap: 10px;
	            padding: 5px 10px;
	            border-radius: 10px;
	            cursor: pointer;
	            color: var(--text);
	            transition: background 0.15s ease;
	        }

	        .dropdown-item:hover {
	            background: var(--surface-muted);
	        }

	        .dropdown-item[aria-selected="true"] {
	            background: var(--surface-muted);
	        }

	        .dropdown-item-text {
	            flex: 1;
	            min-width: 0;
	            overflow: hidden;
	            text-overflow: ellipsis;
	            white-space: nowrap;
	        }

		        select {
		            padding: 15px 45px 15px 20px;
		            font-size: 16px;
		            border: 1px solid var(--border);
		            border-radius: 12px;
		            background: var(--surface);
		            box-shadow: none;
		            transition: all 0.3s ease;
	            cursor: pointer;
	            min-width: 0;
	            width: 100%;
	            appearance: none;
	            -webkit-appearance: none;
	            -moz-appearance: none;
		            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%231d1d1f' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
	            background-size: 16px 16px;
	            background-position: calc(100% - 15px) center;
	            background-repeat: no-repeat;
	        }
        
	        select:hover {
	            border-color: var(--text);
	            transform: none;
	            box-shadow: none;
	            background: var(--surface-muted);
	        }
        
	        select:focus {
	            outline: none;
	            border-color: var(--text);
	            box-shadow: 0 0 0 3px var(--focus);
	        }
        
	        select option {
            padding: 12px 20px;
	            background: var(--surface);
	            color: var(--text);
            font-size: 16px;
            border: none;
            margin: 2px 0;
        }
        
	        select option:hover {
	            background: var(--surface-muted);
	            color: var(--text);
	        }
        
		        select option:checked {
		            background: var(--surface-muted);
		            color: var(--text);
		            font-weight: 400;
		        }
        
		        select optgroup {
		            font-weight: 400;
		            font-size: 14px;
		            color: var(--muted);
		            background: var(--surface-muted);
		            padding: 8px 12px;
		            margin: 4px 0;
		        }
        
		        input {
            width: 220px;
            padding: 15px 20px;
            font-size: 16px;
	            border: 1px solid var(--border);
	            border-radius: 12px;
	            background: var(--surface);
	            box-shadow: none;
	            transition: all 0.3s ease;
	            text-align: right;
		            font-weight: 400;
		            color: var(--text);
		        }
        
	        input:hover {
	            border-color: var(--text);
	            transform: none;
	            box-shadow: none;
	            background: var(--surface-muted);
	        }
        
	        input:focus {
	            outline: none;
	            border-color: var(--text);
	            box-shadow: 0 0 0 3px var(--focus);
	        }
        
        input::placeholder {
            color: #a0a0a0;
            font-weight: normal;
        }
        
		        h1 {
	            font-size: 2.8em;
	            margin-bottom: 35px;
	            margin-top: -5px;
	            color: var(--text);
		            font-weight: 400;
		            letter-spacing: -0.5px;
		        }
        
		        .author {
	            font-size: 0.8em;
	            cursor: pointer;
	            transition: all 0.3s ease;
	            text-decoration: none;
		            font-weight: 400;
		            display: block;
		            opacity: 0.8;
		            color: var(--text);
		        }
	        
	        .author svg {
	            transition: all 0.3s ease;
	            fill: currentColor;
	            stroke: none;
	        }
        
	        .author:hover {
	            opacity: 1;
	            transform: none;
	            filter: none;
	        }
        
	        .author:hover svg {
	            fill: #000000;
	        }
        
	        .social-links {
	            display: grid;
	            grid-template-columns: 1fr auto 1fr;
	            align-items: center;
	            gap: 12px;
	            margin-top: 35px;
	            margin-bottom: 0px;
	        }

	        .social-actions {
	            display: flex;
	            justify-content: flex-end;
	            gap: 10px;
	            align-items: center;
	        }

	        .api-status {
	            text-align: left;
	        }

	        .share-center {
	            display: flex;
	            justify-content: center;
	            gap: 10px;
	        }

	        /* ä¸»é¡µåº•éƒ¨æŒ‰é’® SVG ç»Ÿä¸€çº¯é»‘ï¼ˆä¸æ ‡é¢˜ä¸€è‡´ï¼‰ */
	        .social-links .author {
	            color: #000000;
	        }

	        .social-actions .author,
	        .social-actions .add-to-home-btn {
	            color: #000000;
	        }

	        .social-actions svg {
	            fill: #000000;
	        }

	        /* åˆ†äº«æŒ‰é’®ï¼šæ–‡å­—æ ·å¼ï¼ˆä¸å³ä¾§å›¾æ ‡åˆ†ç¦»ã€å±…ä¸­ï¼‰ */
	        .share-btn {
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            box-sizing: border-box;
	            flex: 0 0 100px;
	            font-size: 14px;
	            padding: 8px 18px;
	            width: 100px;
	            min-width: 0;
	            border: 1px solid var(--border);
	            border-radius: 12px;
	            background: var(--surface);
	            color: var(--text);
	            opacity: 1;
	            cursor: pointer;
	            transition: background 0.2s ease, border-color 0.2s ease;
	            text-decoration: none;
	            white-space: nowrap;
	            overflow: hidden;
	            text-overflow: ellipsis;
	            line-height: 1;
	            -webkit-appearance: none;
	            appearance: none;
	        }
	        
	        .share-btn .btn-content {
	            display: inline-flex;
	            align-items: center;
	            justify-content: center;
	            gap: 8px;
	        }
	        
	        .share-btn svg {
	            width: 16px;
	            height: 16px;
	            fill: none;
	            stroke: currentColor;
	            stroke-width: 2;
	            stroke-linecap: round;
	            stroke-linejoin: round;
	        }

	        .share-btn:hover {
	            background: var(--surface-muted);
	            border-color: var(--text);
	        }

	        .share-btn:active {
	            background: var(--surface-muted);
	            border-color: var(--text);
	        }

	        .share-btn.primary {
	            background: var(--text);
	            color: #ffffff;
	            border-color: var(--text);
	        }

	        .share-btn.primary:hover {
	            background: #000000;
	            border-color: #000000;
	        }

	        .share-btn:focus-visible {
	            outline: none;
	            border-color: var(--text);
	            box-shadow: 0 0 0 3px var(--focus);
	        }
        
	        /* ç§»åŠ¨ç«¯å“åº”å¼è®¾è®¡ */
		        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 30px 20px 20px 20px;
                transform: scale(1);
                margin: 10px;
                border-radius: 15px;
            }
            
            h1 {
                font-size: 2.2em;
                margin-bottom: 15px;
                margin-top: 5px;
            }
            
            .author {
                font-size: 0.7em;
            }
            
	            .social-links {
	                margin-top: 30px;
	                margin-bottom: 0px;
	                gap: 10px;
	            }

	            .share-btn {
	                font-size: 13px;
	                padding: 10px 12px;
	                width: 100px;
	                flex: 0 0 100px;
	            }
            
		            .field {
		                margin: 15px 0;
		                flex-direction: row;
		                align-items: center;
		                gap: 12px;
		            }
		            
		            .select-wrapper {
		                width: 40%;
		            }
            
		            select {
		                min-width: 0;
		                width: 100%;
		                padding: 10px 35px 10px 12px;
		                font-size: 13px;
		                margin-bottom: 0;
		            }

		            .dropdown {
		                width: 100%;
		                min-width: 0;
		            }

	            .dropdown-trigger {
	                padding: 10px 35px 10px 12px;
	                font-size: 13px;
	            }
            
            input {
                width: 55%;
                padding: 10px 12px;
                font-size: 16px;
                text-align: right;
            }
        }
        
		        @media screen and (max-width: 480px) {
            .container {
                padding: 20px 15px 20px 15px;
                margin: 5px;
            }
            
            h1 {
                font-size: 1.8em;
                margin-bottom: 12px;
            }
            
            .author {
                font-size: 0.6em;
            }
            
	            .social-links {
	                margin-top: 20px;
	                margin-bottom: 0px;
	                gap: 8px;
	            }

	            .share-btn {
	                font-size: 12px;
	                padding: 9px 10px;
	                width: 100px;
	                flex: 0 0 100px;
	            }
            
		            .field {
		                margin: 10px 0;
		                gap: 8px;
		            }
		            
		            .select-wrapper {
		                width: 50%;
		            }
            
		            select {
		                min-width: 0;
		                width: 100%;
		                padding: 8px 30px 8px 10px;
		                font-size: 12px;
		            }

		            .dropdown {
		                width: 100%;
		                min-width: 0;
		            }

	            .dropdown-trigger {
	                padding: 8px 30px 8px 10px;
	                font-size: 12px;
	            }
            
            input {
                width: 46%;
                padding: 8px 10px;
                font-size: 16px;
                text-align: right;
            }
        }
        
        /* è‡ªå®šä¹‰ä»£å¸å¼¹çª—æ ·å¼ */
	        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
	            background-color: rgba(0, 0, 0, 0.55);
	            backdrop-filter: blur(5px);
	        }
        
	        .modal-content {
	            background: var(--surface);
	            margin: 5% auto;
	            padding: 0;
	            border-radius: 20px;
	            width: 90%;
	            max-width: 600px;
	            box-shadow: var(--shadow);
	            border: 1px solid var(--border);
	            animation: modalSlideIn 0.3s ease-out;
	        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
	        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
	            padding: 18px 24px;
	            background: var(--surface);
	            color: var(--text);
	            border-bottom: 1px solid var(--border);
	            border-radius: 20px 20px 0 0;
	        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 400;
        }
        
        .close {
            color: var(--text);
            float: right;
            font-size: 28px;
            font-weight: 400;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .close:hover {
            opacity: 0.7;
        }
        
	        .modal-body {
	            padding: 18px 24px;
	        }

	        /* åˆ†äº«å›¾é¢„è§ˆå¼¹çª— */
	        .share-modal-content {
	            padding: 14px 18px 14px 18px;
	        }

		        .share-preview {
		            width: 100%;
		            border: 1px solid var(--border);
		            border-radius: 16px;
		            background: var(--surface-muted);
		            overflow: hidden;
		        }

		        .share-preview img {
		            width: 100%;
		            max-width: 100%;
		            max-height: 70vh;
		            height: auto;
		            display: block;
		        }

	        .share-actions {
	            display: flex;
	            gap: 12px;
	            margin-top: 16px;
	        }

        .share-actions button {
	            flex: 1;
	            border: 1px solid var(--border);
	            background: var(--surface);
	            color: var(--text);
	            padding: 12px 14px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 400;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

	        .share-actions button:hover {
	            background: var(--surface-muted);
	            border-color: var(--text);
	        }

	        .share-actions button.primary {
	            background: var(--text);
	            color: #ffffff;
	            border-color: var(--text);
	        }

	        .share-actions button.primary svg {
	            fill: currentColor;
	        }

	        .share-actions button.primary:hover {
	            background: #000000;
	            border-color: #000000;
	        }
        
        .search-container {
            margin-bottom: 25px;
        }
        
	        .search-container input {
            width: 100%;
            padding: 15px 20px;
            font-size: 16px;
	            border: 1px solid var(--border);
	            border-radius: 12px;
	            background: var(--surface);
	            box-shadow: none;
	            transition: all 0.3s ease;
	            box-sizing: border-box;
	            color: var(--text);
	        }
        
	        .search-container input:focus {
	            outline: none;
	            border-color: var(--text);
	            box-shadow: 0 0 0 3px var(--focus);
	        }
        
        .search-results {
            max-height: 400px;
            overflow-y: auto;
        }
        
	        .token-result {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
	            background: var(--surface);
	            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
	        .token-result:hover {
	            border-color: var(--text);
	            transform: none;
	            box-shadow: none;
	            background: var(--surface-muted);
	        }
        
        .token-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 15px;
            object-fit: cover;
        }
        
        .token-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .token-name-row {
            margin-bottom: 8px;
        }
        
        .token-name {
            font-weight: 400;
            color: var(--text);
        }
        
        .token-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
		        .token-symbol {
		            color: var(--muted);
		            font-weight: 400;
		            text-transform: uppercase;
		        }
        
        .token-price {
            color: var(--muted);
            font-weight: 400;
        }
        
	        .loading {
	            text-align: center;
	            padding: 40px 20px;
	            color: var(--muted);
	        }
        
	        .spinner {
            width: 40px;
            height: 40px;
	            border: 4px solid var(--border);
	            border-top: 4px solid var(--text);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
	        .no-results {
            text-align: center;
            padding: 40px 20px;
	            color: var(--muted);
	            font-style: italic;
	        }
        
	        /* æ·»åŠ åˆ°ä¸»å±å¹•æŒ‰é’®æ ·å¼ */
		        .add-to-home-btn {
	            background: none;
	            border: none;
	            cursor: pointer;
	            transition: all 0.3s ease;
	            text-decoration: none;
	            font-weight: 400;
	            display: block;
	            opacity: 0.8;
	            font-size: 24px;
	            padding: 0;
	            line-height: 1;
	            color: var(--text);
	        }

		        .add-to-home-btn svg {
		            transition: all 0.3s ease;
		            fill: currentColor;
		            stroke: none;
		        }

		        .add-to-home-btn:hover {
		            opacity: 1;
		            transform: none;
		            filter: none;
		        }

		        .add-to-home-btn:hover svg {
		            fill: #000000;
		        }

	        /* Toast æç¤ºæ ·å¼ */
		        .toast {
	            position: fixed;
	            bottom: 32px;
	            left: 50%;
	            transform: translate(-50%, 12px);
		            background: rgba(255, 255, 255, 0.82);
		            color: #1d1d1f;
		            border: 1px solid rgba(0, 0, 0, 0.12);
		            backdrop-filter: blur(12px);
	            padding: 10px 14px;
	            border-radius: 999px;
	            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.16);
	            z-index: 10000;
	            opacity: 0;
	            pointer-events: none;
	            transition: opacity 0.2s ease, transform 0.2s ease;
	            font-size: 13px;
		            font-weight: 400;
		            text-align: center;
		            max-width: 80vw;
		            letter-spacing: -0.2px;
		        }

	        .toast.show {
	            opacity: 1;
	            transform: translate(-50%, 0);
	        }

	        .toast-icon {
	            display: none;
	        }

	        @media screen and (max-width: 768px) {
	            .toast {
	                bottom: 20px;
	                font-size: 12px;
	                padding: 9px 12px;
	            }
	        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ä»·å€¼è§‚çº æ­£å™¨</h1>
        
        <div class="field">
	        <div class="select-wrapper">
	        <select id="currency1">
	            <optgroup label="åŠ å¯†è´§å¸">
	                <option value="BTC" selected>ğŸŸ  BTC</option>
	                <option value="ETH">â™¦ï¸ ETH</option>
	                <option value="SOL">ğŸŸ£ SOL</option>
	                <option value="BNB">ğŸŸ¡ BNB</option>
	                <option value="OKB">âš« OKB</option>
	                <option value="CUSTOM">ğŸ” è‡ªå®šä¹‰ä»£å¸</option>
	                <option value="TEMP_CUSTOM_PLACEHOLDER" style="display: none;"></option>
	            </optgroup>
	            <optgroup label="æ³•å¸">
	                <option value="USD">ğŸ‡ºğŸ‡¸ USD</option>
	                <option value="CNY">ğŸ‡¨ğŸ‡³ CNY</option>
	                <option value="TWD">ğŸ‡¹ğŸ‡¼ TWD</option>
	                <option value="JPY">ğŸ‡¯ğŸ‡µ JPY</option>
	                <option value="KRW">ğŸ‡°ğŸ‡· KRW</option>
	                <option value="SGD">ğŸ‡¸ğŸ‡¬ SGD</option>
	                <option value="AED">ğŸ‡¦ğŸ‡ª AED</option>
	                <option value="HKD">ğŸ‡­ğŸ‡° HKD</option>
	                <option value="MYR">ğŸ‡²ğŸ‡¾ MYR</option>
	            </optgroup>
            <optgroup label="å®ç‰©">
                <option value="ZHUJIAO">ğŸš çŒªè„šé¥­</option>
                <option value="KFC">ğŸ— KFC</option>
                <option value="IN11">ğŸ’ƒ in11å«©æ¨¡</option>
                <option value="IPHONE17">ğŸ“± iPhone17</option>
                <option value="MACBOOK">ğŸ’» MacBook Air</option>
                <option value="ROLEX">âŒš åŠ³åŠ›å£«</option>
                <option value="XIAOMISU7">ğŸï¸ Xiaomi Su7</option>
                <option value="PORSCHE">ğŸï¸ Porsche 718</option>
                <option value="FERRARI">ğŸï¸ Ferrari Roma</option>
	            </optgroup>
	        </select>
	        </div>
	        <input type="text" id="amount1" placeholder="è¾“å…¥é‡‘é¢">
	    </div>
	    
	    <div class="field">
	        <div class="select-wrapper">
	        <select id="currency2">
	            <optgroup label="åŠ å¯†è´§å¸">
	                <option value="BTC">ğŸŸ  BTC</option>
	                <option value="ETH" selected>â™¦ï¸ ETH</option>
	                <option value="SOL">ğŸŸ£ SOL</option>
	                <option value="BNB">ğŸŸ¡ BNB</option>
	                <option value="OKB">âš« OKB</option>
	                <option value="CUSTOM">ğŸ” è‡ªå®šä¹‰ä»£å¸</option>
	                <option value="TEMP_CUSTOM_PLACEHOLDER" style="display: none;"></option>
	            </optgroup>
	            <optgroup label="æ³•å¸">
	                <option value="USD">ğŸ‡ºğŸ‡¸ USD</option>
	                <option value="CNY">ğŸ‡¨ğŸ‡³ CNY</option>
	                <option value="TWD">ğŸ‡¹ğŸ‡¼ TWD</option>
	                <option value="JPY">ğŸ‡¯ğŸ‡µ JPY</option>
	                <option value="KRW">ğŸ‡°ğŸ‡· KRW</option>
	                <option value="SGD">ğŸ‡¸ğŸ‡¬ SGD</option>
	                <option value="AED">ğŸ‡¦ğŸ‡ª AED</option>
	                <option value="HKD">ğŸ‡­ğŸ‡° HKD</option>
	                <option value="MYR">ğŸ‡²ğŸ‡¾ MYR</option>
	            </optgroup>
            <optgroup label="å®ç‰©">
                <option value="ZHUJIAO">ğŸš çŒªè„šé¥­</option>
                <option value="KFC">ğŸ— KFC</option>
                <option value="IN11">ğŸ’ƒ in11å«©æ¨¡</option>
                <option value="IPHONE17">ğŸ“± iPhone17</option>
                <option value="MACBOOK">ğŸ’» MacBook Air</option>
                <option value="ROLEX">âŒš åŠ³åŠ›å£«</option>
                <option value="XIAOMISU7">ğŸï¸ Xiaomi Su7</option>
                <option value="PORSCHE">ğŸï¸ Porsche 718</option>
                <option value="FERRARI">ğŸï¸ Ferrari Roma</option>
	            </optgroup>
	        </select>
	        </div>
	        <input type="text" id="amount2" placeholder="è¾“å…¥é‡‘é¢">
	    </div>
	    
	    <div class="field">
	        <div class="select-wrapper">
	        <select id="currency3">
	            <optgroup label="åŠ å¯†è´§å¸">
	                <option value="BTC">ğŸŸ  BTC</option>
	                <option value="ETH">â™¦ï¸ ETH</option>
	                <option value="SOL" selected>ğŸŸ£ SOL</option>
	                <option value="BNB">ğŸŸ¡ BNB</option>
	                <option value="OKB">âš« OKB</option>
	                <option value="CUSTOM">ğŸ” è‡ªå®šä¹‰ä»£å¸</option>
	                <option value="TEMP_CUSTOM_PLACEHOLDER" style="display: none;"></option>
	            </optgroup>
	            <optgroup label="æ³•å¸">
	                <option value="USD">ğŸ‡ºğŸ‡¸ USD</option>
	                <option value="CNY">ğŸ‡¨ğŸ‡³ CNY</option>
	                <option value="TWD">ğŸ‡¹ğŸ‡¼ TWD</option>
	                <option value="JPY">ğŸ‡¯ğŸ‡µ JPY</option>
	                <option value="KRW">ğŸ‡°ğŸ‡· KRW</option>
	                <option value="SGD">ğŸ‡¸ğŸ‡¬ SGD</option>
	                <option value="AED">ğŸ‡¦ğŸ‡ª AED</option>
	                <option value="HKD">ğŸ‡­ğŸ‡° HKD</option>
	                <option value="MYR">ğŸ‡²ğŸ‡¾ MYR</option>
	            </optgroup>
            <optgroup label="å®ç‰©">
                <option value="ZHUJIAO">ğŸš çŒªè„šé¥­</option>
                <option value="KFC">ğŸ— KFC</option>
                <option value="IN11">ğŸ’ƒ in11å«©æ¨¡</option>
                <option value="IPHONE17">ğŸ“± iPhone17</option>
                <option value="MACBOOK">ğŸ’» MacBook Air</option>
                <option value="ROLEX">âŒš åŠ³åŠ›å£«</option>
                <option value="XIAOMISU7">ğŸï¸ Xiaomi Su7</option>
                <option value="PORSCHE">ğŸï¸ Porsche 718</option>
                <option value="FERRARI">ğŸï¸ Ferrari Roma</option>
	            </optgroup>
	        </select>
	        </div>
	        <input type="text" id="amount3" placeholder="è¾“å…¥é‡‘é¢">
	    </div>
	    
	    <div class="field">
	        <div class="select-wrapper">
	        <select id="currency4">
	            <optgroup label="åŠ å¯†è´§å¸">
	                <option value="BTC">ğŸŸ  BTC</option>
	                <option value="ETH">â™¦ï¸ ETH</option>
	                <option value="SOL">ğŸŸ£ SOL</option>
	                <option value="BNB">ğŸŸ¡ BNB</option>
	                <option value="OKB">âš« OKB</option>
	                <option value="CUSTOM">ğŸ” è‡ªå®šä¹‰ä»£å¸</option>
	                <option value="TEMP_CUSTOM_PLACEHOLDER" style="display: none;"></option>
	            </optgroup>
	            <optgroup label="æ³•å¸">
	                <option value="USD" selected>ğŸ‡ºğŸ‡¸ USD</option>
	                <option value="CNY">ğŸ‡¨ğŸ‡³ CNY</option>
	                <option value="TWD">ğŸ‡¹ğŸ‡¼ TWD</option>
	                <option value="JPY">ğŸ‡¯ğŸ‡µ JPY</option>
	                <option value="KRW">ğŸ‡°ğŸ‡· KRW</option>
	                <option value="SGD">ğŸ‡¸ğŸ‡¬ SGD</option>
	                <option value="AED">ğŸ‡¦ğŸ‡ª AED</option>
	                <option value="HKD">ğŸ‡­ğŸ‡° HKD</option>
	                <option value="MYR">ğŸ‡²ğŸ‡¾ MYR</option>
	            </optgroup>
            <optgroup label="å®ç‰©">
                <option value="ZHUJIAO">ğŸš çŒªè„šé¥­</option>
                <option value="KFC">ğŸ— KFC</option>
                <option value="IN11">ğŸ’ƒ in11å«©æ¨¡</option>
                <option value="IPHONE17">ğŸ“± iPhone17</option>
                <option value="MACBOOK">ğŸ’» MacBook Air</option>
                <option value="ROLEX">âŒš åŠ³åŠ›å£«</option>
                <option value="XIAOMISU7">ğŸï¸ Xiaomi Su7</option>
                <option value="PORSCHE">ğŸï¸ Porsche 718</option>
                <option value="FERRARI">ğŸï¸ Ferrari Roma</option>
	            </optgroup>
	        </select>
	        </div>
	        <input type="text" id="amount4" placeholder="è¾“å…¥é‡‘é¢">
	    </div>
	    
	    <div class="field">
	        <div class="select-wrapper">
	        <select id="currency5">
	            <optgroup label="åŠ å¯†è´§å¸">
	                <option value="BTC">ğŸŸ  BTC</option>
	                <option value="ETH">â™¦ï¸ ETH</option>
	                <option value="SOL">ğŸŸ£ SOL</option>
	                <option value="BNB">ğŸŸ¡ BNB</option>
	                <option value="OKB">âš« OKB</option>
	                <option value="CUSTOM">ğŸ” è‡ªå®šä¹‰ä»£å¸</option>
	                <option value="TEMP_CUSTOM_PLACEHOLDER" style="display: none;"></option>
	            </optgroup>
	            <optgroup label="æ³•å¸">
	                <option value="USD">ğŸ‡ºğŸ‡¸ USD</option>
	                <option value="CNY" selected>ğŸ‡¨ğŸ‡³ CNY</option>
	                <option value="TWD">ğŸ‡¹ğŸ‡¼ TWD</option>
	                <option value="JPY">ğŸ‡¯ğŸ‡µ JPY</option>
	                <option value="KRW">ğŸ‡°ğŸ‡· KRW</option>
	                <option value="SGD">ğŸ‡¸ğŸ‡¬ SGD</option>
	                <option value="AED">ğŸ‡¦ğŸ‡ª AED</option>
	                <option value="HKD">ğŸ‡­ğŸ‡° HKD</option>
	                <option value="MYR">ğŸ‡²ğŸ‡¾ MYR</option>
	            </optgroup>
            <optgroup label="å®ç‰©">
                <option value="ZHUJIAO">ğŸš çŒªè„šé¥­</option>
                <option value="KFC">ğŸ— KFC</option>
                <option value="IN11">ğŸ’ƒ in11å«©æ¨¡</option>
                <option value="IPHONE17">ğŸ“± iPhone17</option>
                <option value="MACBOOK">ğŸ’» MacBook Air</option>
                <option value="ROLEX">âŒš åŠ³åŠ›å£«</option>
                <option value="XIAOMISU7">ğŸï¸ Xiaomi Su7</option>
                <option value="PORSCHE">ğŸï¸ Porsche 718</option>
                <option value="FERRARI">ğŸï¸ Ferrari Roma</option>
	            </optgroup>
	        </select>
	        </div>
	        <input type="text" id="amount5" placeholder="è¾“å…¥é‡‘é¢">
	    </div>
	    
	    <div class="field">
	        <div class="select-wrapper">
	        <select id="currency6">
	            <optgroup label="åŠ å¯†è´§å¸">
	                <option value="BTC">ğŸŸ  BTC</option>
	                <option value="ETH">â™¦ï¸ ETH</option>
	                <option value="SOL">ğŸŸ£ SOL</option>
	                <option value="BNB">ğŸŸ¡ BNB</option>
	                <option value="OKB">âš« OKB</option>
	                <option value="CUSTOM">ğŸ” è‡ªå®šä¹‰ä»£å¸</option>
	                <option value="TEMP_CUSTOM_PLACEHOLDER" style="display: none;"></option>
	            </optgroup>
	            <optgroup label="æ³•å¸">
	                <option value="USD">ğŸ‡ºğŸ‡¸ USD</option>
	                <option value="CNY">ğŸ‡¨ğŸ‡³ CNY</option>
	                <option value="TWD">ğŸ‡¹ğŸ‡¼ TWD</option>
	                <option value="JPY">ğŸ‡¯ğŸ‡µ JPY</option>
	                <option value="KRW">ğŸ‡°ğŸ‡· KRW</option>
	                <option value="SGD">ğŸ‡¸ğŸ‡¬ SGD</option>
	                <option value="AED">ğŸ‡¦ğŸ‡ª AED</option>
	                <option value="HKD" selected>ğŸ‡­ğŸ‡° HKD</option>
	                <option value="MYR">ğŸ‡²ğŸ‡¾ MYR</option>
	            </optgroup>
            <optgroup label="å®ç‰©">
                <option value="ZHUJIAO">ğŸš çŒªè„šé¥­</option>
                <option value="KFC">ğŸ— KFC</option>
                <option value="IN11">ğŸ’ƒ in11å«©æ¨¡</option>
                <option value="IPHONE17">ğŸ“± iPhone17</option>
                <option value="MACBOOK">ğŸ’» MacBook Air</option>
                <option value="ROLEX">âŒš åŠ³åŠ›å£«</option>
                <option value="XIAOMISU7">ğŸï¸ Xiaomi Su7</option>
                <option value="PORSCHE">ğŸï¸ Porsche 718</option>
                <option value="FERRARI">ğŸï¸ Ferrari Roma</option>
	            </optgroup>
	        </select>
	        </div>
	        <input type="text" id="amount6" placeholder="è¾“å…¥é‡‘é¢">
	    </div>
    
	    <div class="social-links">
	        <!-- APIçŠ¶æ€æŒ‡ç¤ºå™¨ -->
	        <div id="apiStatus" class="api-status" style="font-size: 11px; color: #6c757d; text-align: left;">
	            æ­£åœ¨åˆå§‹åŒ–æ±‡ç‡æœåŠ¡...
	        </div>

	        <!-- åˆ†äº«ç»“æœï¼ˆå±…ä¸­ï¼‰ -->
	        <div class="share-center">
	            <button id="shareBtn" class="share-btn primary" title="ç”Ÿæˆåˆ†äº«å›¾">
	                <span class="btn-content">
	                    <svg viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                        <rect x="4" y="5" width="16" height="14" rx="3"></rect>
	                        <path d="M8.5 14.5l2.5-3 3 3.5 2-2 2 2.5"></path>
	                        <path d="M9 10.5h.01"></path>
	                    </svg>
	                    åˆ†äº«ç»“æœ&nbsp;
	                </span>
	            </button>
	            <button id="shareSiteBtn" class="share-btn" type="button" title="å¤åˆ¶ç½‘ç«™åˆ†äº«æ–‡æ¡ˆ">
	                <span class="btn-content">
	                    <svg viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                        <path d="M10 13a5 5 0 0 1 0-7l.7-.7a5 5 0 0 1 7.1 7.1l-.7.7"></path>
	                        <path d="M14 11a5 5 0 0 1 0 7l-.7.7a5 5 0 0 1-7.1-7.1l.7-.7"></path>
	                    </svg>
	                    å¤åˆ¶ç½‘å€&nbsp;
	                </span>
	            </button>
	        </div>
	        
	        <!-- å³ä¾§æŒ‰é’®ç»„ -->
	        <div class="social-actions">
	            <a href="https://x.com/wolfyxbt" target="_blank" class="author">
	                <!-- X å®˜æ–¹æ ‡å¿—ï¼ˆç®€åŒ–ç‰ˆè·¯å¾„ï¼‰ -->
	                <svg width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                    <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zM17.083 19.77h1.833L7.084 4.126H5.117z"/>
	                </svg>
	            </a>
	            <a href="https://github.com/WolfyXBT/ValuesCorrector" target="_blank" class="author">
	                <!-- GitHub å®˜æ–¹ Octocat æ ‡å¿—ï¼ˆç»å…¸è½®å»“ï¼‰ -->
	                <svg width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                    <path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.44 9.8 8.21 11.39.6.11.82-.26.82-.58v-2.02c-3.34.73-4.03-1.41-4.03-1.41-.55-1.39-1.33-1.76-1.33-1.76-1.09-.75.08-.73.08-.73 1.2.08 1.84 1.24 1.84 1.24 1.07 1.83 2.81 1.3 3.49 1 .11-.78.42-1.3.76-1.6-2.66-.31-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.12-.31-.54-1.53.12-3.18 0 0 1.01-.32 3.3 1.23.96-.27 1.98-.4 3-.41 1.02.01 2.05.14 3.01.41 2.29-1.55 3.3-1.23 3.3-1.23.65 1.65.24 2.87.12 3.18.77.84 1.23 1.91 1.23 3.22 0 4.61-2.81 5.62-5.49 5.92.43.37.82 1.1.82 2.22v3.29c0 .32.22.69.83.58C20.57 21.8 24 17.3 24 12 24 5.37 18.63 0 12 0z"/>
	                </svg>
	            </a>
	            <!-- æ·»åŠ åˆ°ä¸»å±å¹•æŒ‰é’® -->
	            <button id="addToHomeBtn" class="author add-to-home-btn" title="æ·»åŠ åˆ°ä¸»å±å¹•">
	                <svg width="24" height="24" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                    <path d="M8 1.5h8A3.5 3.5 0 0 1 19.5 5v14A3.5 3.5 0 0 1 16 22.5H8A3.5 3.5 0 0 1 4.5 19V5A3.5 3.5 0 0 1 8 1.5zm0 2A1.5 1.5 0 0 0 6.5 5v14A1.5 1.5 0 0 0 8 20.5h8A1.5 1.5 0 0 0 17.5 19V5A1.5 1.5 0 0 0 16 3.5H8z"/>
	                    <path d="M12 7.5c.55 0 1 .45 1 1v2.5h2.5a1 1 0 1 1 0 2H13v2.5a1 1 0 1 1-2 0V13H8.5a1 1 0 1 1 0-2H11V8.5c0-.55.45-1 1-1z"/>
	                </svg>
	            </button>
	        </div>
	    </div>

		    <script>
		        let rates = {};
		        let updating = false;
		        let lastInputField = 1; // è®°å½•æœ€åä¸€æ¬¡è¾“å…¥æ•°å­—çš„æ ä½
		        let localStorageAvailable = false;
		        let loadRatesInFlight = null;

		        // ===== æ•°å­—æ˜¾ç¤ºæ ¼å¼åŒ–ï¼ˆç”¨äºç»“æœå±•ç¤ºï¼‰=====
		        function toPlainDecimalString(num) {
		            const s = String(num);
		            if (!/[eE]/.test(s)) return s;

		            const [coeffRaw, expRaw] = s.toLowerCase().split('e');
		            const exp = parseInt(expRaw, 10);

		            let coeff = coeffRaw;
		            let sign = '';
		            if (coeff.startsWith('-')) {
		                sign = '-';
		                coeff = coeff.slice(1);
		            }

		            const parts = coeff.split('.');
		            const intPart = parts[0] || '0';
		            const fracPart = parts[1] || '';
		            const digits = (intPart + fracPart).replace(/^0+(?=\d)/, '') || '0';

		            if (exp >= 0) {
		                const zeros = exp - fracPart.length;
		                if (zeros >= 0) return sign + digits + '0'.repeat(zeros);
		                const idx = intPart.length + exp;
		                return sign + digits.slice(0, idx) + '.' + digits.slice(idx);
		            }

		            const zeros = (-exp) - intPart.length;
		            if (zeros >= 0) return sign + '0.' + '0'.repeat(zeros) + digits;
		            const idx = intPart.length + exp; // exp ä¸ºè´Ÿ
		            return sign + digits.slice(0, idx) + '.' + digits.slice(idx);
		        }

		        function formatNumberForDisplay(input) {
		            const n = typeof input === 'number' ? input : Number(input);
		            if (!Number.isFinite(n) || n === 0) return '0';

		            const sign = n < 0 ? '-' : '';
		            const abs = Math.abs(n);

		            const groupThousands = (intStr) => intStr.replace(/\B(?=(\d{3})+(?!\d))/g, ',');

		            // è§„åˆ™ 1ï¼š>= 1ï¼Œæœ€å¤š 2 ä½å°æ•°ï¼ˆå››èˆäº”å…¥ï¼‰ï¼Œä¸å›ºå®šå°æ•°ä½
		            if (abs >= 1) {
		                const rounded = Math.round((abs + Number.EPSILON) * 100) / 100;
		                let s = rounded.toFixed(2).replace(/\.?0+$/, '');
		                const [i, f] = s.split('.');
		                return sign + groupThousands(i) + (f ? `.${f}` : '');
		            }

		            // è§„åˆ™ 2ï¼š0 < n < 1ï¼Œæ˜¾ç¤ºåˆ° 2 ä¸ªæœ‰æ•ˆæ•°å­—ï¼ˆæŒ‰ç¤ºä¾‹ï¼šæˆªæ–­åˆ°ç¬¬ 2 ä¸ªæœ‰æ•ˆæ•°å­—ï¼Œä¸ä½¿ç”¨ç§‘å­¦è®¡æ•°æ³•ï¼‰
		            const plain = toPlainDecimalString(abs);
		            const frac = (plain.split('.')[1] || '').replace(/[^\d]/g, '');
		            const firstNonZero = frac.search(/[1-9]/);
		            if (firstNonZero === -1) return '0';

		            const cut = Math.min(frac.length, firstNonZero + 2);
		            const shown = frac.slice(0, cut);
		            return sign + '0.' + shown;
		        }
		        
		        // ===== API / ç¼“å­˜å·¥å…· =====
		        const CACHE_VERSION = 1;
		        const CACHE_KEYS = {
	            presetCryptoPrices: `valueConverter:caches:v${CACHE_VERSION}:presetCryptoPrices`,
	            binanceSpotPrices: `valueConverter:caches:v${CACHE_VERSION}:binanceSpotPrices`,
	            okxSpotPrices: `valueConverter:caches:v${CACHE_VERSION}:okxSpotPrices`,
	            fiatRates: `valueConverter:caches:v${CACHE_VERSION}:fiatRates`,
	            coingeckoTokenPrice: `valueConverter:caches:v${CACHE_VERSION}:coingeckoTokenPrice`
	        };
	        
	        const memoryCache = new Map();
	        
	        function nowMs() {
	            return Date.now();
	        }
	        
	        function readCache(key, maxAgeMs) {
	            const raw = (() => {
	                if (localStorageAvailable) {
	                    try {
	                        return localStorage.getItem(key);
	                    } catch (e) {
	                        return null;
	                    }
	                }
	                return memoryCache.get(key) || null;
	            })();
	            
	            if (!raw) return null;
	            
	            try {
	                const payload = typeof raw === 'string' ? JSON.parse(raw) : raw;
	                if (!payload || typeof payload.ts !== 'number') return null;
	                if (typeof maxAgeMs === 'number' && maxAgeMs >= 0) {
	                    if (nowMs() - payload.ts > maxAgeMs) return null;
	                }
	                return payload;
	            } catch (e) {
	                return null;
	            }
	        }
	        
	        function writeCache(key, data) {
	            const payload = { ts: nowMs(), data };
	            if (localStorageAvailable) {
	                try {
	                    localStorage.setItem(key, JSON.stringify(payload));
	                } catch (e) {
	                    // localStorage æ»¡äº†æˆ–ä¸å¯ç”¨æ—¶ï¼Œé€€å›å†…å­˜ç¼“å­˜
	                    memoryCache.set(key, payload);
	                }
	            } else {
	                memoryCache.set(key, payload);
	            }
	        }
	        
	        function formatAge(ts) {
	            const diffSec = Math.max(0, Math.floor((nowMs() - ts) / 1000));
	            if (diffSec < 60) return `${diffSec}ç§’å‰`;
	            const diffMin = Math.floor(diffSec / 60);
	            if (diffMin < 60) return `${diffMin}åˆ†é’Ÿå‰`;
	            const diffHr = Math.floor(diffMin / 60);
	            return `${diffHr}å°æ—¶å‰`;
	        }
	        
	        async function fetchJsonWithTimeout(url, options = {}, timeoutMs = 8000) {
	            const controller = new AbortController();
	            const timeout = setTimeout(() => controller.abort(), timeoutMs);
	            try {
	                const res = await fetch(url, { ...options, signal: controller.signal });
	                return res;
	            } finally {
	                clearTimeout(timeout);
	            }
	        }
	        
	        // ===== é¢„è®¾å¸ç§å®æ—¶ä»·æ ¼ï¼ˆBinance + OKXï¼‰ =====
	        // è¯´æ˜ï¼šç½‘é¡µç«¯ OKX REST é€šå¸¸ç¼ºå°‘ CORS å¤´ï¼Œæ— æ³•ç›´æ¥ fetchï¼Œå› æ­¤è¿™é‡Œä½¿ç”¨ OKX WebSocket å…¬å…±é¢‘é“è·å– SOL/OKBã€‚
	        // ä»·æ ¼ä½¿ç”¨ USDT æŠ¥ä»·ï¼Œé»˜è®¤æŒ‰ 1 USDT â‰ˆ 1 USD å¤„ç†ï¼ˆå¯¹å¤§å¤šæ•°åœºæ™¯è¶³å¤Ÿï¼›å¦‚éœ€æ›´ç²¾ç¡®å¯å†åŠ  USDT/USD æ ¡å‡†ï¼‰ã€‚
	        let okxWs = null;
	        let okxWsBackoffMs = 1000;
	        let okxWsLastConnectAttempt = 0;
	        let scheduledRatesRefreshTimer = null;
	        
	        // { SOL: { price, ts }, OKB: { price, ts } }
	        const okxLivePrices = new Map();
	        
	        function scheduleRatesRefresh(reason) {
	            if (scheduledRatesRefreshTimer) return;
	            scheduledRatesRefreshTimer = setTimeout(async () => {
	                scheduledRatesRefreshTimer = null;
	                try {
	                    await loadRates({ forceRefresh: false, reason: reason || 'scheduledRefresh' });
	                    // è‹¥é¡µé¢ä¸Šå·²æœ‰è¾“å…¥ï¼Œåˆ·æ–°åä»¥æœ€åè¾“å…¥æ ä½ä¸ºåŸºå‡†é‡ç®—
	                    const lastAmount = document.getElementById(`amount${lastInputField}`)?.value?.trim?.() || '';
	                    if (lastAmount !== '') convert(lastInputField);
	                } catch (e) {
	                    console.log('è®¡åˆ’å†…åˆ·æ–°å¤±è´¥:', e);
	                }
	            }, 1500); // é˜²æŠ–ï¼šé¿å… OKX é«˜é¢‘æ¨é€å¯¼è‡´åå¤é‡ç®—
	        }
	        
	        function startOkxWebSocket() {
	            // è‹¥å·²è¿æ¥/æ­£åœ¨è¿æ¥ï¼Œç›´æ¥è¿”å›
	            if (okxWs && (okxWs.readyState === WebSocket.OPEN || okxWs.readyState === WebSocket.CONNECTING)) return;
	            
	            const now = nowMs();
	            if (now - okxWsLastConnectAttempt < okxWsBackoffMs) return;
	            okxWsLastConnectAttempt = now;
	            
	            try {
	                okxWs = new WebSocket('wss://ws.okx.com:8443/ws/v5/public');
	            } catch (e) {
	                console.log('OKX WebSocket åˆå§‹åŒ–å¤±è´¥:', e);
	                okxWs = null;
	                okxWsBackoffMs = Math.min(30_000, okxWsBackoffMs * 2);
	                return;
	            }
	            
	            okxWs.onopen = () => {
	                okxWsBackoffMs = 1000;
	                apiStatus.okx = true;
	                const sub = {
	                    op: 'subscribe',
	                    args: [
	                        { channel: 'tickers', instId: 'SOL-USDT' },
	                        { channel: 'tickers', instId: 'OKB-USDT' }
	                    ]
	                };
	                okxWs.send(JSON.stringify(sub));
	            };
	            
	            okxWs.onmessage = (evt) => {
	                try {
	                    const msg = JSON.parse(evt.data);
	                    if (msg?.event) return;
	                    const channel = msg?.arg?.channel;
	                    if (channel !== 'tickers') return;
	                    
	                    const instId = msg?.arg?.instId;
	                    const last = msg?.data?.[0]?.last;
	                    const price = typeof last === 'string' ? parseFloat(last) : (typeof last === 'number' ? last : NaN);
	                    if (!instId || !Number.isFinite(price) || price <= 0) return;
	                    
	                    const symbol = instId.startsWith('SOL-') ? 'SOL' : instId.startsWith('OKB-') ? 'OKB' : null;
	                    if (!symbol) return;
	                    
	                    okxLivePrices.set(symbol, { price, ts: nowMs() });
	                    writeCache(CACHE_KEYS.okxSpotPrices, Object.fromEntries(okxLivePrices.entries()));
	                    scheduleRatesRefresh('okxWsUpdate');
	                } catch (e) {
	                    // å¿½ç•¥è§£æé”™è¯¯
	                }
	            };
	            
	            okxWs.onerror = () => {
	                apiStatus.okx = false;
	            };
	            
	            okxWs.onclose = () => {
	                apiStatus.okx = false;
	                okxWs = null;
	                okxWsBackoffMs = Math.min(30_000, okxWsBackoffMs * 2);
	                setTimeout(() => startOkxWebSocket(), okxWsBackoffMs);
	            };
	        }
	        
	        async function getBinancePresetPrices({ forceRefresh = false } = {}) {
	            const TTL_MS = 30 * 1000; // 30ç§’
	            if (!forceRefresh) {
	                const cached = readCache(CACHE_KEYS.binanceSpotPrices, TTL_MS);
	                if (cached?.data) return { prices: cached.data, source: 'cache', ts: cached.ts };
	            }
	            
	            const url = 'https://api.binance.com/api/v3/ticker/price?symbols=%5B%22BTCUSDT%22,%22ETHUSDT%22,%22BNBUSDT%22%5D';
	            const res = await fetchJsonWithTimeout(url, { method: 'GET' }, 8000);
	            
	            if (!res.ok) {
	                const error = new Error(`Binance è¯·æ±‚å¤±è´¥: ${res.status}`);
	                error.status = res.status;
	                throw error;
	            }
	            
	            const arr = await res.json();
	            if (!Array.isArray(arr)) throw new Error('Binance è¿”å›æ•°æ®å¼‚å¸¸');
	            
	            const out = {};
	            for (const item of arr) {
	                const sym = item?.symbol;
	                const priceStr = item?.price;
	                const price = typeof priceStr === 'string' ? parseFloat(priceStr) : NaN;
	                if (sym === 'BTCUSDT') out.BTC = price;
	                if (sym === 'ETHUSDT') out.ETH = price;
	                if (sym === 'BNBUSDT') out.BNB = price;
	            }
	            
	            for (const k of ['BTC', 'ETH', 'BNB']) {
	                if (!Number.isFinite(out[k]) || out[k] <= 0) throw new Error(`Binance è¿”å›æ•°æ®ä¸å®Œæ•´ï¼Œç¼ºå°‘ ${k} ä»·æ ¼`);
	            }
	            
	            writeCache(CACHE_KEYS.binanceSpotPrices, out);
	            return { prices: out, source: 'realtime', ts: nowMs() };
	        }
	        
	        function getOkxPresetPrices({ forceRefresh = false } = {}) {
	            // OKX WebSocket ä»·æ ¼çš„â€œå®æ—¶â€åˆ¤æ–­çª—å£æ›´çŸ­
	            const LIVE_MAX_AGE_MS = 15 * 1000; // 15ç§’å†…è§†ä¸ºå®æ—¶
	            
	            const sol = okxLivePrices.get('SOL');
	            const okb = okxLivePrices.get('OKB');
	            const bothLive =
	                sol && okb &&
	                (nowMs() - sol.ts <= LIVE_MAX_AGE_MS) &&
	                (nowMs() - okb.ts <= LIVE_MAX_AGE_MS);
	            
	            if (!forceRefresh && bothLive) {
	                return { prices: { SOL: sol.price, OKB: okb.price }, source: 'realtime', ts: Math.min(sol.ts, okb.ts) };
	            }
	            
	            // ç”¨æŒä¹…åŒ–ç¼“å­˜å…œåº•ï¼ˆå³ä½¿ä¸æ˜¯å®æ—¶ï¼Œä¹Ÿæ¯”â€œä¸å¯ç”¨â€å¼ºï¼‰
	            const cached = readCache(CACHE_KEYS.okxSpotPrices, -1);
	            if (cached?.data) {
	                const cachedSol = cached.data?.SOL?.price;
	                const cachedOkb = cached.data?.OKB?.price;
	                if (Number.isFinite(cachedSol) && Number.isFinite(cachedOkb)) {
	                    return { prices: { SOL: cachedSol, OKB: cachedOkb }, source: 'cache', ts: cached.ts };
	                }
	            }
	            
	            throw new Error('OKX ä»·æ ¼å°šæœªå°±ç»ªï¼ˆWebSocket æœªè¿æ¥æˆ–æœªæ”¶åˆ°æ•°æ®ï¼‰');
	        }
	        
	        async function getPresetCryptoPrices({ forceRefresh = false } = {}) {
	            const TTL_MS = 30 * 1000; // 30ç§’ï¼šç»„åˆä»·æ ¼ç¼“å­˜
	            if (!forceRefresh) {
	                const cached = readCache(CACHE_KEYS.presetCryptoPrices, TTL_MS);
	                if (cached?.data) return { prices: cached.data, source: 'cache', ts: cached.ts };
	            }
	            
	            // ç¡®ä¿ OKX WS åœ¨åå°å¯åŠ¨ï¼ˆä¸ä¼šé˜»å¡ï¼‰
	            startOkxWebSocket();
	            
	            const [binanceRes, okxRes] = await Promise.all([
	                (async () => {
	                    try {
	                        const r = await getBinancePresetPrices({ forceRefresh });
	                        apiStatus.binance = true;
	                        return r;
	                    } catch (e) {
	                        apiStatus.binance = false;
	                        throw e;
	                    }
	                })(),
	                (async () => {
	                    try {
	                        const r = getOkxPresetPrices({ forceRefresh });
	                        apiStatus.okx = true;
	                        return r;
	                    } catch (e) {
	                        apiStatus.okx = false;
	                        throw e;
	                    }
	                })()
	            ]);
	            
	            const prices = {
	                ...binanceRes.prices,
	                ...okxRes.prices
	            };
	            
	            for (const k of ['BTC', 'ETH', 'BNB', 'SOL', 'OKB']) {
	                if (!Number.isFinite(prices[k]) || prices[k] <= 0) throw new Error(`é¢„è®¾å¸ç§ä»·æ ¼ä¸å®Œæ•´ï¼Œç¼ºå°‘ ${k}`);
	            }
	            
	            writeCache(CACHE_KEYS.presetCryptoPrices, prices);
	            return { prices, source: 'realtime', ts: nowMs() };
	        }
	        
	        async function getFiatRates({ forceRefresh = false } = {}) {
	            const TTL_MS = 6 * 60 * 60 * 1000; // 6å°æ—¶ï¼šæ³•å¸æ±‡ç‡æ›´æ–°æ²¡é‚£ä¹ˆé¢‘ç¹
	            if (!forceRefresh) {
	                const cached = readCache(CACHE_KEYS.fiatRates, TTL_MS);
	                if (cached?.data) {
	                    return { fiatData: cached.data, source: 'cache', ts: cached.ts };
	                }
	            }
	            
	            const url = 'https://api.exchangerate-api.com/v4/latest/USD';
	            const res = await fetchJsonWithTimeout(url, { method: 'GET' }, 8000);
	            if (!res.ok) {
	                const error = new Error(`ExchangeRate è¯·æ±‚å¤±è´¥: ${res.status}`);
	                error.status = res.status;
	                throw error;
	            }
	            
	            const fiatData = await res.json();
	            if (!fiatData?.rates) throw new Error('ExchangeRate è¿”å›æ•°æ®å¼‚å¸¸');
	            
	            writeCache(CACHE_KEYS.fiatRates, fiatData);
	            return { fiatData, source: 'realtime', ts: nowMs() };
	        }
	        
	        // PWA æ·»åŠ åˆ°ä¸»å±å¹•åŠŸèƒ½
	        let deferredPrompt;
	        const addToHomeBtn = document.getElementById('addToHomeBtn');
	        const shareBtn = document.getElementById('shareBtn');

        // æ˜¾ç¤º Toast æç¤º
        function showToast(message) {
            const toast = document.getElementById('shareToast');
            if (toast) {
	                if (message) {
	                    const textEl = toast.querySelector('.toast-text');
	                    if (textEl) textEl.textContent = message;
	                }

                // æ˜¾ç¤º toast
                toast.classList.add('show');

                // 3ç§’åè‡ªåŠ¨éšè—
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
        }
        
	        function getShareRows() {
	            const rows = [];
	            const presetCryptoSet = new Set(['BTC', 'ETH', 'SOL', 'BNB', 'OKB']);
	            for (let i = 1; i <= 6; i++) {
	                const amountEl = document.getElementById(`amount${i}`);
	                const selectEl = document.getElementById(`currency${i}`);
	                if (!amountEl || !selectEl) continue;
                
                const rawAmount = (amountEl.value || '').trim();
                if (!rawAmount) continue;
                
                let label = '';
	                let logoType = 'none';
	                let logo = '';
	                let value = selectEl.value;
	                const isCrypto = (value === 'CUSTOM') || presetCryptoSet.has(value);
	                
	                if (value === 'CUSTOM') {
	                    const customOption = selectEl.querySelector('option[value="CUSTOM"]');
	                    const displayText = customOption?.getAttribute('data-display-text');
	                    label = displayText ? `${displayText}` : 'è‡ªå®šä¹‰ä»£å¸';
	                    // åˆ†äº«å›¾ï¼šåŠ å¯†è´§å¸ä¸å±•ç¤º Logoï¼ˆæŒ‰éœ€åªåœ¨ ticker å‰åŠ  $ï¼‰
	                    logoType = 'none';
	                    logo = '';
	                } else {
	                    // ä¼˜å…ˆä½¿ç”¨ä¸ç•Œé¢ä¸€è‡´çš„æ˜ å°„ï¼ˆemoji/logo + æ˜¾ç¤ºæ–‡æœ¬ï¼‰
	                    const mapped = (typeof currencyLogos !== 'undefined') ? currencyLogos[value] : null;
	                    if (mapped) {
	                        label = mapped.text || value;
	                        // åˆ†äº«å›¾ï¼šåŠ å¯†è´§å¸ä¸å±•ç¤º Logoï¼›éåŠ å¯†æŒ‰åŸæ¥çš„ emoji å±•ç¤º
	                        if (presetCryptoSet.has(value)) {
	                            logoType = 'none';
	                            logo = '';
	                        } else if (mapped.type === 'emoji') {
	                            logoType = 'emoji';
	                            logo = mapped.logo || '';
	                        } else {
	                            logoType = 'none';
	                            logo = '';
	                        }
	                    } else {
	                        const opt = selectEl.querySelector(`option[value="${CSS.escape(value)}"]`);
	                        label = (opt?.textContent || value).trim();
	                    }
	                }
	                
	                rows.push({
	                    index: i,
	                    label,
	                    amount: rawAmount,
	                    value,
	                    isCrypto,
	                    logoType,
	                    logo
	                });
	            }
	            return rows;
	        }
        
	        function formatShareTimestamp() {
	            const d = new Date();
	            const pad = (n) => String(n).padStart(2, '0');
	            return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ï½¥ ${pad(d.getHours())}:${pad(d.getMinutes())}`;
	        }
        
        function roundRect(ctx, x, y, w, h, r) {
            const radius = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + w, y, x + w, y + h, radius);
            ctx.arcTo(x + w, y + h, x, y + h, radius);
            ctx.arcTo(x, y + h, x, y, radius);
            ctx.arcTo(x, y, x + w, y, radius);
            ctx.closePath();
        }

	        function drawCircleLogo(ctx, { x, y, size, logoType, logo, bitmap, isDark }) {
	            const r = size / 2;
	            ctx.save();
            
            // èƒŒæ™¯åœ†
            roundRect(ctx, x - r, y - r, size, size, r);
            ctx.fillStyle = isDark ? 'rgba(255,255,255,0.18)' : '#ffffff';
            ctx.fill();
            ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.28)' : '#d2d2d7';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // å†…å®¹
            if (logoType === 'image' && bitmap) {
                ctx.beginPath();
                ctx.arc(x, y, r - 2, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(bitmap, x - (r - 2), y - (r - 2), (r - 2) * 2, (r - 2) * 2);
            } else if (logoType === 'emoji' && logo) {
                ctx.fillStyle = isDark ? '#ffffff' : '#1d1d1f';
                ctx.font = `400 ${Math.floor(size * 0.52)}px "PingFang SC"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(logo, x, y + 1);
            } else {
                ctx.fillStyle = isDark ? '#ffffff' : '#1d1d1f';
                ctx.font = `400 ${Math.floor(size * 0.34)}px "PingFang SC"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â€¢', x, y);
            }
            
	            ctx.restore();
	        }

	        // åˆ†äº«å›¾ä¸“ç”¨ï¼šç»˜åˆ¶æ— åœ†æ¡†çš„ Logoï¼ˆä»…ç»˜åˆ¶å†…å®¹æœ¬èº«ï¼‰
	        function drawInlineLogo(ctx, { x, y, size, logoType, logo, bitmap }) {
	            ctx.save();
	            if (logoType === 'image' && bitmap) {
	                ctx.drawImage(bitmap, x - size / 2, y - size / 2, size, size);
	            } else if (logoType === 'emoji' && logo) {
	                ctx.font = `400 ${Math.floor(size * 0.9)}px "PingFang SC"`;
	                ctx.textAlign = 'center';
	                ctx.textBaseline = 'middle';
	                ctx.fillText(logo, x, y + 1);
	            }
	            ctx.restore();
	        }
        
	        async function generateSharePngBlob() {
	            const rows = getShareRows();
	            if (rows.length === 0) {
	                throw new Error('æ²¡æœ‰å¯åˆ†äº«çš„æ¢ç®—ç»“æœï¼ˆè¯·å…ˆè¾“å…¥ä»»æ„é‡‘é¢ï¼‰');
	            }

			            // æ¨ªå‘åˆ†äº«å›¾ï¼ˆlandscapeï¼‰
			            const BASE_W = 1350;
			            const MAX_W = 20000; // å…è®¸æ›´å®½çš„åˆ†äº«å›¾ï¼ˆå—æµè§ˆå™¨/è®¾å¤‡ç”»å¸ƒä¸Šé™å½±å“ï¼‰
			            let W = BASE_W;
			            const scale = 2;
			            const ACCENT = '#FF9F0A'; // Apple ç³»ç»Ÿæ©˜è‰²ï¼ˆåè®¡ç®—å™¨é£æ ¼ï¼‰
		            const BG = '#000000';
		            const SURFACE = '#000000';
		            const TEXT = '#F5F5F7';
		            const MUTED = '#8E8E93';
		            const BORDER = '#2C2C2E';
			            const PILL_BG = '#1C1C1E';

			            // åŠ¨æ€é«˜åº¦ï¼šæ ¹æ®å®é™…æœ‰å€¼çš„è¡Œæ•°æ”¶ç¼©ç”»å¸ƒï¼Œé¿å…åº•éƒ¨å¤§æ®µç©ºç™½
			            const marginScale = 0.5; // ç•™ç™½å‡å°‘ 50%
			            const pad = Math.round(72 * marginScale);
			            const sideInset = Math.round(56 * marginScale);
			            const metaTopOffset = 30;
				            const metaLineStep = 37;
			            const titleBaselineOffset = 130; // é¿å…ä¸å·¦ä¸Šè§’ä¿¡æ¯é‡å 
			            const afterTitleToRows = 70;
				            const baseLineH = 104;
				            const basePillH = 86;
				            const SOURCE_ROW_SCALE = 2; // ç¬¬ä¸€è¡Œï¼ˆæºå€¼ï¼‰æ•´ä½“æ”¾å¤§å€æ•°
				            const SECONDARY_AMOUNT_SCALE = 1.44; // ç¬¬2ï½6è¡Œæ•°å­—æ”¾å¤§æ¯”ä¾‹ï¼ˆç¼©å° 20%ï¼‰
				            const PRIMARY_TEXT_SCALE = 2;
				            const primaryAmountFontSizeForLayout = Math.round(36 * SOURCE_ROW_SCALE * PRIMARY_TEXT_SCALE);
				            const primaryTickerFontSizeForLayout = Math.round(34 * SOURCE_ROW_SCALE * 0.7 * PRIMARY_TEXT_SCALE);
				            const primaryPillHForLayout = Math.max(
				                basePillH * SOURCE_ROW_SCALE,
				                Math.round(primaryAmountFontSizeForLayout * 1.05 + primaryTickerFontSizeForLayout * 1.05 + 28)
				            );
						            const maxRows = Math.min(6, rows.length);
					            const colGap = Math.round(56 * marginScale);
					            const baseTotalInnerW = BASE_W - pad * 2 - sideInset * 2;
					            const minLeftColW = 420;
					            const minRightColW = 320;
					            const leftColWBase = Math.max(minLeftColW, Math.floor((baseTotalInnerW - colGap) * 0.55));
					            const rightColWBase = Math.max(minRightColW, baseTotalInnerW - colGap - leftColWBase);

					            // åŠ¨æ€å¢å®½ï¼šå½“ä¸»ä½“/å‰¯ä½“å‡ºç°å¤§ä½æ•°æ•°å­—æ—¶ï¼Œå›¾ç‰‡å®½åº¦éšä¹‹å˜å®½ä»¥ä¿è¯å®Œæ•´æ˜¾ç¤º
					            const chainForMeasure = rows.slice(0, maxRows);
					            const primaryForMeasure = chainForMeasure[0];
					            const secondaryForMeasure = chainForMeasure.slice(1);

					            const mctx = document.createElement('canvas').getContext('2d');
					            const measureText = (font, text) => {
					                mctx.font = font;
					                return mctx.measureText(String(text ?? '')).width;
					            };

					            let requiredLeftColW = leftColWBase;
					            let requiredRightColW = rightColWBase;

						            if (primaryForMeasure) {
						                const shouldDrawLogo = !primaryForMeasure.isCrypto;
						                const amountFont = `400 ${primaryAmountFontSizeForLayout}px "PingFang SC"`;
						                const tickerFont = `400 ${primaryTickerFontSizeForLayout}px "PingFang SC"`;
						                const amountW = measureText(amountFont, primaryForMeasure.amount);
						                const tickerLabel = primaryForMeasure.isCrypto ? `$${primaryForMeasure.label}` : primaryForMeasure.label;
						                const tickerW = measureText(tickerFont, tickerLabel);
						                const logoW = shouldDrawLogo ? ((44 * SOURCE_ROW_SCALE) + (12 * SOURCE_ROW_SCALE)) : 0;
						                const rowW = Math.max(amountW, logoW + tickerW) + 20;
						                requiredLeftColW = Math.max(requiredLeftColW, rowW);
						            }

						            if (secondaryForMeasure.length > 0) {
						                const prefixFont = '400 30px "PingFang SC"';
						                const tickerFont = '400 34px "PingFang SC"';
						                const amountFont = `400 ${Math.round(36 * SECONDARY_AMOUNT_SCALE)}px "PingFang SC"`;
						                const padX = 22;
						                const iconSize = 44;
						                const iconGap = 12;
					                const prefix = 'çº¦ç­‰äº â‰ˆ';
					                const prefixW = measureText(prefixFont, prefix) + 14;

					                for (const r of secondaryForMeasure) {
					                    const shouldDrawLogo = !r.isCrypto;
					                    const amountW = measureText(amountFont, r.amount) + 14;
					                    const tickerLabel = r.isCrypto ? `$${r.label}` : r.label;
					                    const tickerW = measureText(tickerFont, tickerLabel);
					                    const logoW = shouldDrawLogo ? (iconSize + iconGap) : 0;
					                    const rowW = padX + prefixW + amountW + logoW + tickerW + padX + 20;
					                    requiredRightColW = Math.max(requiredRightColW, rowW);
					                }
					            }

					            const requiredTotalInnerW = requiredLeftColW + colGap + requiredRightColW;
					            if (requiredTotalInnerW > baseTotalInnerW) {
					                W = Math.min(MAX_W, BASE_W + Math.ceil(requiredTotalInnerW - baseTotalInnerW));
					            }

					            const totalInnerW = W - pad * 2 - sideInset * 2;
					            let rightColW = Math.max(
					                minRightColW,
					                Math.min(totalInnerW - colGap - minLeftColW, requiredRightColW)
					            );
					            let leftColW = totalInnerW - colGap - rightColW;
					            if (leftColW < requiredLeftColW) {
					                leftColW = Math.max(requiredLeftColW, minLeftColW);
					                rightColW = totalInnerW - colGap - leftColW;
					                if (rightColW < minRightColW) {
					                    rightColW = minRightColW;
					                    leftColW = totalInnerW - colGap - rightColW;
					                }
					            }

					            const rowsStartY = pad + titleBaselineOffset + afterTitleToRows;
					            const lineGap = 18;
					            const primaryLineH = Math.max(baseLineH, primaryPillHForLayout + lineGap);
				            const secondaryLineH = Math.max(baseLineH, basePillH + lineGap);
				            const secondaryCount = Math.max(0, maxRows - 1);
				            const leftHeight = primaryLineH;
				            const rightHeight = secondaryCount * secondaryLineH;
			            const rowsHeight = Math.max(leftHeight, rightHeight);
			            const bottomInside = Math.round(56 * marginScale * 0.5); // ä¸‹æ–¹ç•™ç™½å†å‡å°‘ 50%
			            const cardH = Math.max(360, Math.ceil((rowsStartY - pad) + rowsHeight + bottomInside));
			            const H = cardH + pad * 2;
	            
	            const canvas = document.createElement('canvas');
	            canvas.width = W * scale;
	            canvas.height = H * scale;
	            const ctx = canvas.getContext('2d');
	            ctx.scale(scale, scale);
            
            // èƒŒæ™¯
	            ctx.fillStyle = BG;
	            ctx.fillRect(0, 0, W, H);
            
	            // ç”»å¸ƒå†…å®¹åŒºåŸŸï¼ˆä¸å†ç»˜åˆ¶å¤–å±‚å¡ç‰‡è¾¹æ¡†ï¼‰
		            const cardX = pad;
		            const cardY = pad;
		            const cardW = W - pad * 2;
		            // cardH å·²æŒ‰å†…å®¹åŠ¨æ€è®¡ç®—
            
		            // æ ‡é¢˜
			            const titleX = cardX + sideInset;
			            const titleRightX = cardX + cardW - sideInset;
			            let cursorY = cardY + titleBaselineOffset;
			            
					            const shareTitle = 'ä»·å€¼è§‚çº æ­£å™¨';
					            const titleFontSize = 101;
					            ctx.fillStyle = TEXT;
					            ctx.font = `400 ${titleFontSize}px "PingFang SC"`;
					            ctx.fillText(shareTitle, titleX, cursorY);
				            
				            // å³ä¸Šè§’ä¿¡æ¯ï¼ˆä¸æ ‡é¢˜æœ€é¡¶éƒ¨å¯¹é½ï¼‰
				            const titleMetrics = ctx.measureText(shareTitle);
				            const titleAscent = titleMetrics.actualBoundingBoxAscent ?? Math.round(titleFontSize * 0.85);
				            const titleTopY = cursorY - titleAscent;
					            const metaYOffset = Math.round(titleFontSize * 0.1); // æ—¥æœŸ + GitHub æ•´ä½“ä¸‹ç§» 10%
					            
					            ctx.textAlign = 'right';
				            ctx.fillStyle = 'rgba(245,245,247,0.7)';
					            const githubLine = 'https://github.com/wolfyxbt/ValuesCorrector';
					            const dateLine = `${formatShareTimestamp()}`;
				            
				            const dateFontSize = 28; // æ—¥æœŸå­—ä½“ç¼©å° 5%ï¼ˆçº¦ 29 -> 28ï¼‰
				            const githubFontSize = 24; // GitHub å­—ä½“æ”¾å¤§ 10%ï¼ˆçº¦ 22 -> 24ï¼‰
				            
				            ctx.font = `400 ${dateFontSize}px "PingFang SC"`;
				            const dateMetrics = ctx.measureText(dateLine);
				            const dateAscent = dateMetrics.actualBoundingBoxAscent ?? Math.round(dateFontSize * 0.85);
				            const dateY = titleTopY + dateAscent + metaYOffset;
				            ctx.fillText(dateLine, titleRightX, dateY);
				            
				            ctx.font = `400 ${githubFontSize}px "PingFang SC"`;
				            ctx.fillText(githubLine, titleRightX, dateY + metaLineStep);
			            
				            // æ¢¯å½¢/é˜¶æ¢¯å¸ƒå±€ï¼šç¬¬ä¸€è¡Œæºå€¼ï¼Œå…¶ä½™è¡Œä»¥â€œçº¦ç­‰äº â‰ˆâ€å¼€å¤´å¹¶é€è¡Œå³ç§»
				            cursorY += afterTitleToRows;
				            const rowsBottomLimit = cardY + cardH - bottomInside;
				            // ç»“æ„ï¼šç¬¬ä¸€è¡Œï¼ˆä¸»ä½“ï¼‰åœ¨å·¦ä¾§ï¼Œå…¶ä½™è¡Œï¼ˆå‰¯ä½“ï¼‰åœ¨å³ä¾§
				            const leftX = titleX;
				            const rightX = titleRightX - rightColW;
			            // é¡ºåºï¼šä¸¥æ ¼ä¿æŒä¸ UI æ˜¾ç¤ºä¸€è‡´ï¼ˆ1â†’6ï¼‰
			            const chain = rows.slice(0, maxRows);
			            const primaryRow = chain[0];
			            const secondaryRows = chain.slice(1);
			            // baseLineH/basePillH/SOURCE_ROW_SCALE å·²åœ¨ä¸Šæ–¹ç”¨äºåŠ¨æ€é«˜åº¦è®¡ç®—
			            
			            function ellipsize(text, maxWidth) {
			                if (ctx.measureText(text).width <= maxWidth) return text;
			                let t = text;
		                while (t.length > 1 && ctx.measureText(t + 'â€¦').width > maxWidth) {
		                    t = t.slice(0, -1);
		                }
		                return t + 'â€¦';
		            }
		            
					            function drawRow({ row, x, yTop, w, scale, showPrefix }) {
					                const primaryTextScale = showPrefix ? 1 : PRIMARY_TEXT_SCALE; // ç¬¬ä¸€ä¸ªæ¢ç®—å•ä½â€œæ•°å­—+å•ä½â€æ”¾å¤§ 200%
					                const amountFontSize = Math.round(36 * scale * (showPrefix ? SECONDARY_AMOUNT_SCALE : 1) * primaryTextScale);
					                const tickerFontSize = Math.round(34 * scale * (showPrefix ? 1 : 0.7) * primaryTextScale);
					                const pillH = showPrefix
					                    ? (basePillH * scale)
					                    : Math.max(basePillH * scale, Math.round(amountFontSize * 1.05 + tickerFontSize * 1.05 + 28));
					                const yMid = yTop + pillH / 2;
					                // ä¸»ä½“è¡Œï¼ˆä¸æ˜¾ç¤º prefixï¼‰éœ€è¦ä¸æ ‡é¢˜å·¦è¾¹ç¼˜å¯¹é½ï¼šå»æ‰å·¦ä¾§å†…ç¼©
					                const padX = showPrefix ? (22 * scale) : 0;
					                const iconSize = 44 * scale;
					                const iconGap = 12 * scale;
					                const textStartX = x + padX;
					                const textY = yMid + (12 * scale) + (showPrefix ? 0 : Math.round(pillH * 0.2)); // ä¸»ä½“è¡Œä¸‹ç§» 20%
				                const shouldDrawLogo = !row.isCrypto;
				                const prefix = showPrefix ? 'çº¦ç­‰äº â‰ˆ' : '';
				                
				                ctx.textAlign = 'left';
				                ctx.textBaseline = 'alphabetic';
				                let cursorX = textStartX;
				                
					                if (prefix) {
					                    ctx.fillStyle = TEXT;
					                    ctx.font = '400 30px "PingFang SC"';
					                    ctx.fillText(prefix, cursorX, textY);
					                    cursorX += ctx.measureText(prefix).width + 14;
					                }
				                
						                // amount
						                ctx.fillStyle = ACCENT;
						                ctx.font = `400 ${amountFontSize}px "PingFang SC"`;
						                let reservedTail = 0;
						                const tickerLabel = row.isCrypto ? `$${row.label}` : row.label;
						                if (showPrefix) {
						                    const prevFont = ctx.font;
						                    ctx.font = `400 ${tickerFontSize}px "PingFang SC"`;
						                    const tickerW = ctx.measureText(tickerLabel).width;
						                    ctx.font = prevFont;
						                    reservedTail = (shouldDrawLogo ? (iconSize + iconGap) : 0) + tickerW + 20;
						                }
					                const amountMaxW = Math.max(140, w - (cursorX - x) - reservedTail);
					                const amountText = ellipsize(row.amount, amountMaxW);
					                ctx.fillText(amountText, cursorX, textY);
				                cursorX += ctx.measureText(amountText).width + 14;

					                // tickerï¼šä¸»ä½“è¡Œæ¢è¡Œåˆ°ä¸‹æ–¹ï¼›å‰¯ä½“è¡Œä¿æŒåŒä¸€è¡Œ
					                ctx.fillStyle = TEXT;
					                ctx.font = `400 ${tickerFontSize}px "PingFang SC"`;

					                if (!showPrefix) {
					                    const unitY = textY + Math.round(amountFontSize * 0.92);
					                    let unitCursorX = textStartX;
					                    if (shouldDrawLogo) {
					                        const iconCx = unitCursorX + iconSize / 2;
					                        const iconCy = unitY - Math.round(iconSize * 0.1);
					                        drawInlineLogo(ctx, {
					                            x: iconCx,
					                            y: iconCy,
					                            size: iconSize,
					                            logoType: row.logoType,
					                            logo: row.logo,
					                            bitmap: null
					                        });
					                        unitCursorX += iconSize + iconGap;
					                    }
					                    const tickerMaxW = Math.max(120, (x + w - padX) - unitCursorX);
					                    const ticker = ellipsize(tickerLabel, tickerMaxW);
					                    ctx.fillText(ticker, unitCursorX, unitY);
					                } else {
					                    if (shouldDrawLogo) {
					                        const iconCx = cursorX + iconSize / 2;
					                        const iconCy = yMid;
					                        drawInlineLogo(ctx, {
					                            x: iconCx,
					                            y: iconCy,
					                            size: iconSize,
					                            logoType: row.logoType,
					                            logo: row.logo,
					                            bitmap: null
					                        });
					                        cursorX += iconSize + iconGap;
					                    }

					                    const tickerMaxW = Math.max(120, (x + w - padX) - cursorX);
					                    const ticker = ellipsize(tickerLabel, tickerMaxW);
					                    ctx.fillText(ticker, cursorX, textY);
					                }
					            }
				            
						            // å·¦ä¾§ï¼šä¸»ä½“ï¼ˆç¬¬ä¸€è¡Œï¼‰
						            if (primaryRow) {
						                const primaryPillH = primaryPillHForLayout;
						                const primaryYTopOffset = -Math.round(H * 0.1); // ä¸»ä½“æ•´ä½“ä¸Šç§» 10%
						                const primaryYTopIdeal = Math.round((H - primaryPillH) / 2) + primaryYTopOffset;
						                const primaryYTopMin = cursorY;
						                const primaryYTopMax = Math.max(primaryYTopMin, rowsBottomLimit - primaryPillH);
						                const primaryYTop = Math.min(primaryYTopMax, Math.max(primaryYTopMin, primaryYTopIdeal));
					                drawRow({
					                    row: primaryRow,
					                    x: leftX,
				                    yTop: primaryYTop,
				                    w: leftColW,
				                    scale: SOURCE_ROW_SCALE,
				                    showPrefix: false
				                });
				            }
				            
				            // å³ä¾§ï¼šå‰¯ä½“ï¼ˆå…¶ä½™è¡Œï¼‰
				            let rightCursorY = cursorY;
				            for (let i = 0; i < secondaryRows.length; i++) {
				                drawRow({
				                    row: secondaryRows[i],
				                    x: rightX,
				                    yTop: rightCursorY,
				                    w: rightColW,
				                    scale: 1,
				                    showPrefix: true
				                });
				                rightCursorY += secondaryLineH;
				            }
	            
		            // å³ä¸Šè§’å·²å±•ç¤º GitHub é“¾æ¥ï¼Œåº•éƒ¨ä¸å†æ˜¾ç¤ºç½‘å€
	            
	            return await new Promise((resolve, reject) => {
                canvas.toBlob((blob) => {
                    if (!blob) reject(new Error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥'));
                    else resolve(blob);
                }, 'image/png', 0.92);
            });
        }

        let shareImageBlob = null;
        let shareImageObjectUrl = null;

        function closeShareImageModal() {
            const modal = document.getElementById('shareImageModal');
            if (modal) modal.style.display = 'none';
            const img = document.getElementById('shareImagePreview');
            if (img) img.src = '';
            if (shareImageObjectUrl) {
                URL.revokeObjectURL(shareImageObjectUrl);
                shareImageObjectUrl = null;
            }
            shareImageBlob = null;
        }

	        function openShareImageModal(blob) {
	            shareImageBlob = blob;
	            const modal = document.getElementById('shareImageModal');
	            const img = document.getElementById('shareImagePreview');
	            if (!modal || !img) return;

	            if (shareImageObjectUrl) URL.revokeObjectURL(shareImageObjectUrl);
	            shareImageObjectUrl = URL.createObjectURL(blob);
	            img.src = shareImageObjectUrl;
	            modal.style.display = 'block';
	        }

        async function copyShareImageToClipboard() {
            if (!shareImageBlob) throw new Error('å›¾ç‰‡æœªå°±ç»ª');

            if (!navigator.clipboard || typeof ClipboardItem === 'undefined') {
                throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒå¤åˆ¶å›¾ç‰‡ï¼ˆè¯·ä½¿ç”¨ä¸‹è½½ï¼‰');
            }

            const item = new ClipboardItem({ 'image/png': shareImageBlob });
            await navigator.clipboard.write([item]);
        }

        function downloadShareImage() {
            if (!shareImageBlob) throw new Error('å›¾ç‰‡æœªå°±ç»ª');

            const filename = `ä»·å€¼è§‚çº æ­£å™¨-æ¢ç®—ç»“æœ-${Date.now()}.png`;
            const url = URL.createObjectURL(shareImageBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

	        function setupShareImageModalListeners() {
            const modal = document.getElementById('shareImageModal');
            const copyBtn = document.getElementById('copyShareImageBtn');
            const downloadBtn = document.getElementById('downloadShareImageBtn');
            if (!modal || !copyBtn || !downloadBtn) return;

            if (!copyBtn.dataset.bound) {
                copyBtn.dataset.bound = '1';
                copyBtn.addEventListener('click', async () => {
                    try {
                        await copyShareImageToClipboard();
                        showToast('å›¾ç‰‡å·²å¤åˆ¶');
                        console.log('âœ… å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    } catch (e) {
                        console.log('å¤åˆ¶å›¾ç‰‡å¤±è´¥:', e);
                        alert(`âŒ å¤åˆ¶å›¾ç‰‡å¤±è´¥ï¼š\n\n${e?.message || e}\n\nä½ å¯ä»¥ç‚¹å‡»â€œä¸‹è½½å›¾ç‰‡â€ä¿å­˜åå†åˆ†äº«ã€‚`);
                    }
                });
            }

            if (!downloadBtn.dataset.bound) {
                downloadBtn.dataset.bound = '1';
                downloadBtn.addEventListener('click', () => {
                    try {
                        downloadShareImage();
                        showToast('å›¾ç‰‡å·²ä¸‹è½½');
                        console.log('âœ… å›¾ç‰‡å·²ä¸‹è½½');
                    } catch (e) {
                        console.log('ä¸‹è½½å›¾ç‰‡å¤±è´¥:', e);
                        alert(`âŒ ä¸‹è½½å›¾ç‰‡å¤±è´¥ï¼š\n\n${e?.message || e}`);
                    }
                });
            }

            if (!modal.dataset.bound) {
                modal.dataset.bound = '1';

                // ç‚¹å‡»é®ç½©å…³é—­
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) closeShareImageModal();
                });

                // ESC å…³é—­
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.style.display === 'block') {
                        closeShareImageModal();
                    }
                });
            }
        }

        // å…¨å±€ï¼šç‚¹å‡»ç©ºç™½å¤„å…³é—­æ‰€æœ‰è‡ªå®šä¹‰ä¸‹æ‹‰
        window.addEventListener('click', (e) => {
            const target = e.target;
            if (!(target instanceof Element)) return;
            if (target.closest('.dropdown')) return;
            if (target.closest('.dropdown-menu')) return;
            closeAllDropdowns();
        });

        // ESCï¼šå…³é—­ä¸‹æ‹‰
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeAllDropdowns();
        });

        // æ»šåŠ¨/ç¼©æ”¾ï¼šé‡å®šä½å·²æ‰“å¼€çš„ä¸‹æ‹‰èœå•
        window.addEventListener('scroll', () => {
            document.querySelectorAll('.dropdown.open').forEach((dd) => positionDropdownMenu(dd));
        }, { passive: true });

        window.addEventListener('resize', () => {
            document.querySelectorAll('.dropdown.open').forEach((dd) => positionDropdownMenu(dd));
        });

	        // åˆ†äº«æŒ‰é’®åŠŸèƒ½ï¼šç”Ÿæˆæ¢ç®—ç»“æœåˆ†äº«å›¾ PNGï¼Œå¹¶æ‰“å¼€é¢„è§ˆå¼¹çª—
	        if (shareBtn) {
		            shareBtn.addEventListener('click', async () => {
			                try {
			                    const blob = await generateSharePngBlob();

			                    openShareImageModal(blob);
			                    console.log('âœ… åˆ†äº«å›¾å·²ç”Ÿæˆï¼ˆPNGï¼‰ï¼Œå·²æ‰“å¼€é¢„è§ˆ');
			                } catch (err) {
	                    console.error('ç”Ÿæˆ/åˆ†äº«å¤±è´¥:', err);
	                    alert(`âŒ ç”Ÿæˆåˆ†äº«å›¾å¤±è´¥ï¼š\n\n${err?.message || err}`);
	                }
	            });
	        }

	        // åˆ†äº«ç½‘ç«™æŒ‰é’®ï¼šå¤åˆ¶åˆ†äº«æ–‡æ¡ˆ
	        const shareSiteBtn = document.getElementById('shareSiteBtn');
	        if (shareSiteBtn) {
	            shareSiteBtn.addEventListener('click', async () => {
	                const text = 'ä»·å€¼è§‚çº æ­£å™¨ï¼šhttps://wolfyxbt.github.io/ValuesCorrector/';
	                try {
	                    if (navigator.clipboard?.writeText) {
	                        await navigator.clipboard.writeText(text);
	                    } else {
	                        const ta = document.createElement('textarea');
	                        ta.value = text;
	                        ta.setAttribute('readonly', '');
	                        ta.style.position = 'fixed';
	                        ta.style.left = '-9999px';
	                        ta.style.top = '0';
	                        document.body.appendChild(ta);
	                        ta.select();
	                        document.execCommand('copy');
	                        ta.remove();
	                    }
	                    showToast('ç½‘å€å·²å¤åˆ¶');
	                    console.log('âœ… ç½‘ç«™åˆ†äº«æ–‡æ¡ˆå·²å¤åˆ¶');
	                } catch (e) {
	                    console.log('å¤åˆ¶ç½‘ç«™åˆ†äº«æ–‡æ¡ˆå¤±è´¥:', e);
	                    alert(`âŒ å¤åˆ¶å¤±è´¥ï¼š\n\n${e?.message || e}\n\nä½ å¯ä»¥æ‰‹åŠ¨å¤åˆ¶ï¼š\n${text}`);
	                }
	            });
	        }

        // ç›‘å¬beforeinstallpromptäº‹ä»¶
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('PWAå®‰è£…æç¤ºäº‹ä»¶è§¦å‘');
            e.preventDefault();
            deferredPrompt = e;
            // æ˜¾ç¤ºæ·»åŠ åˆ°ä¸»å±å¹•æŒ‰é’®
            addToHomeBtn.style.display = 'block';
        });
        
        // ç‚¹å‡»æ·»åŠ åˆ°ä¸»å±å¹•æŒ‰é’®
        addToHomeBtn.addEventListener('click', async () => {
            const isMobile = isMobileDevice();
            
            if (!isMobile) {
                // æ¡Œé¢ç«¯æç¤º
                showDesktopPrompt();
                return;
            }
            
            if (deferredPrompt) {
                // Android Chrome: ç›´æ¥è§¦å‘å®‰è£…æç¤º
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`PWAå®‰è£…ç»“æœ: ${outcome}`);
                if (outcome === 'accepted') {
                    alert('åº”ç”¨å·²æˆåŠŸæ·»åŠ åˆ°ä¸»å±å¹•ï¼ğŸ‰');
                }
                deferredPrompt = null;
            } else {
                // ç§»åŠ¨ç«¯æ‰‹åŠ¨æŒ‡å¼•
                if (window.navigator.standalone === false) {
                    // iOS Safari: æ˜¾ç¤ºæ›´ç›´è§‚çš„æ·»åŠ æŒ‡å¼•
                    showIOSInstallPrompt();
                } else {
                    // æ˜¾ç¤ºæ‰‹åŠ¨æ·»åŠ æŒ‡å¼•
                    showManualInstallInstructions();
                }
            }
        });
        
        // æ¡Œé¢ç«¯æç¤º
        function showDesktopPrompt() {
            const popup = document.createElement('div');
            popup.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
	                    font-family: "PingFang SC";
                    animation: fadeIn 0.3s ease-out;
                ">
                    <div style="
                        background: white;
                        padding: 30px;
                        border-radius: 20px;
                        text-align: center;
                        max-width: 380px;
                        margin: 20px;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                        animation: slideUp 0.3s ease-out;
                    ">
                        <div style="margin-bottom: 20px;">
                            <svg width="60" height="60" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
	                                <path d="M17 1H7c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zM7 4V3h10v1H7zM7 18V6h10v12H7zM7 21v-1h10v1H7z" fill="#1d1d1f"/>
	                                <path d="M12 8l-4 4h2.5v3h3v-3H16l-4-4z" fill="#1d1d1f"/>
	                            </svg>
	                        </div>
	                        <h3 style="margin: 0 0 15px 0; color: #1d1d1f; font-size: 24px;">ç§»åŠ¨è®¾å¤‡ä¸“äº«</h3>
	                        <p style="color: #6e6e73; font-size: 16px; line-height: 1.6; margin: 15px 0;">
	                            æ·»åŠ åˆ°ä¸»å±å¹•åŠŸèƒ½éœ€è¦åœ¨æ‰‹æœºä¸Šä½¿ç”¨
	                        </p>
	                        <p style="color: #6e6e73; font-size: 14px; line-height: 1.5; margin: 15px 0;">
	                            è¯·ç”¨æ‰‹æœºæµè§ˆå™¨æ‰“å¼€æœ¬ç½‘ç«™ï¼Œ<br>
	                            å³å¯å°†ä»·å€¼è§‚çº æ­£å™¨æ·»åŠ åˆ°æ‰‹æœºä¸»å±å¹•
	                        </p>
	                        <button onclick="this.parentElement.parentElement.remove()" style="
	                            background: #1d1d1f;
	                            color: white;
	                            border: none;
	                            padding: 12px 30px;
                            border-radius: 25px;
                            font-size: 16px;
                            cursor: pointer;
                            transition: transform 0.2s;
                            margin-top: 10px;
                        ">çŸ¥é“äº†</button>
                    </div>
                </div>
                <style>
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes slideUp {
                        from { transform: translateY(30px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                </style>
            `;
            document.body.appendChild(popup);
            
            // ç‚¹å‡»å¤–éƒ¨å…³é—­
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    popup.remove();
                }
            });
        }

        // iOSä¸“é—¨çš„å®‰è£…æç¤º
        function showIOSInstallPrompt() {
            const popup = document.createElement('div');
            popup.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                    font-family: "PingFang SC";
                    animation: fadeIn 0.3s ease-out;
                ">
                    <div style="
                        background: white;
                        padding: 25px;
                        border-radius: 20px;
                        text-align: center;
                        max-width: 320px;
                        margin: 20px;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                        animation: slideUp 0.3s ease-out;
                    ">
                        <div style="margin-bottom: 15px;">
                            <svg width="50" height="50" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
	                                <path d="M17 1H7c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-2-2-2zM7 4V3h10v1H7zM7 18V6h10v12H7zM7 21v-1h10v1H7z" fill="#1d1d1f"/>
	                                <path d="M12 8l-4 4h2.5v3h3v-3H16l-4-4z" fill="#1d1d1f"/>
	                            </svg>
	                        </div>
	                        <h3 style="margin: 0 0 15px 0; color: #1d1d1f; font-size: 20px;">æ·»åŠ åˆ°ä¸»å±å¹•</h3>
	                        <p style="color: #1d1d1f; font-size: 14px; line-height: 1.5; margin: 10px 0;">
	                            <span style="display: inline-block; width: 20px; height: 20px; background: #1d1d1f; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; margin-right: 8px;">1</span>
	                            ç‚¹å‡»åº•éƒ¨çš„"åˆ†äº«"æŒ‰é’®
	                        </p>
	                        <p style="color: #1d1d1f; font-size: 14px; line-height: 1.5; margin: 10px 0;">
	                            <span style="display: inline-block; width: 20px; height: 20px; background: #1d1d1f; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; margin-right: 8px;">2</span>
	                            é€‰æ‹©"æ·»åŠ åˆ°ä¸»å±å¹•"
	                        </p>
	                        <p style="color: #1d1d1f; font-size: 14px; line-height: 1.5; margin: 10px 0 20px 0;">
	                            <span style="display: inline-block; width: 20px; height: 20px; background: #1d1d1f; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; margin-right: 8px;">3</span>
	                            ç‚¹å‡»"æ·»åŠ "å®Œæˆ
	                        </p>
	                        <button onclick="this.parentElement.parentElement.remove()" style="
	                            background: #1d1d1f;
	                            color: white;
	                            border: none;
	                            padding: 12px 30px;
                            border-radius: 25px;
                            font-size: 16px;
                            cursor: pointer;
                            transition: transform 0.2s;
                        ">çŸ¥é“äº†</button>
                    </div>
                </div>
                <style>
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes slideUp {
                        from { transform: translateY(30px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                </style>
            `;
            document.body.appendChild(popup);
            
            // ç‚¹å‡»å¤–éƒ¨å…³é—­
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    popup.remove();
                }
            });
        }

        // æ‰‹åŠ¨æ·»åŠ æŒ‡å¼•
        function showManualInstallInstructions() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isAndroid = /Android/.test(navigator.userAgent);
            
            let message = '';
            if (isIOS) {
                message = 'åœ¨Safariä¸­ï¼š\n1. ç‚¹å‡»åº•éƒ¨åˆ†äº«æŒ‰é’® ğŸ“¤\n2. é€‰æ‹©"æ·»åŠ åˆ°ä¸»å±å¹•"\n3. ç‚¹å‡»"æ·»åŠ "';
            } else if (isAndroid) {
                message = 'åœ¨Chromeä¸­ï¼š\n1. ç‚¹å‡»å³ä¸Šè§’èœå• â‹®\n2. é€‰æ‹©"æ·»åŠ åˆ°ä¸»å±å¹•"\n3. ç‚¹å‡»"æ·»åŠ "';
            } else {
                message = 'è¯·åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šä½¿ç”¨æµè§ˆå™¨çš„"æ·»åŠ åˆ°ä¸»å±å¹•"åŠŸèƒ½';
            }
            
            alert(message);
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»å®‰è£…
        window.addEventListener('appinstalled', () => {
            console.log('PWAå·²å®‰è£…åˆ°ä¸»å±å¹•');
            addToHomeBtn.style.display = 'none';
        });
        
        // æ£€æµ‹ç§»åŠ¨è®¾å¤‡å¹¶æ˜¾ç¤ºæŒ‰é’®
        function isMobileDevice() {
            return window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // åˆå§‹åŒ–æŒ‰é’®æ˜¾ç¤ºï¼ˆæ‰€æœ‰è®¾å¤‡éƒ½æ˜¾ç¤ºï¼‰
        setTimeout(() => {
            if (addToHomeBtn) {
                addToHomeBtn.style.display = 'block';
                console.log('æ·»åŠ åˆ°ä¸»å±å¹•æŒ‰é’®å·²æ˜¾ç¤º');
            }
        }, 500);
        
        // APIçŠ¶æ€è·Ÿè¸ª
	        let apiStatus = {
	            preset: true,
	            binance: true,
	            okx: true,
	            exchangerate: true,
	            coingecko: true, // ä»…ç”¨äºâ€œè‡ªå®šä¹‰ä»£å¸â€ç›¸å…³åŠŸèƒ½ï¼ˆæœç´¢/ä»·æ ¼ï¼‰
	            rateLimited: false,
	            backoffUntil: 0
	        };

	        // æ›´æ–°APIçŠ¶æ€æ˜¾ç¤º
	        function updateApiStatusDisplay(isRealTime, errorMessage) {
	            const statusElement = document.getElementById('apiStatus');
	            if (!statusElement) return;
            
            // ç¡®ä¿çŠ¶æ€å…ƒç´ å§‹ç»ˆå¯è§
            statusElement.style.display = 'block';
            
	            // æ–°ç‰ˆï¼šå…è®¸ä¼ å…¥å¯¹è±¡ä»¥è‡ªå®šä¹‰æ–‡æ¡ˆ
	            if (typeof isRealTime === 'object' && isRealTime) {
	                statusElement.innerHTML = isRealTime.message || 'æ±‡ç‡çŠ¶æ€æœªçŸ¥';
	                statusElement.style.color = isRealTime.color || '#6c757d';
	                return;
	            }
	            
	            if (isRealTime) {
	                statusElement.innerHTML = 'å®æ—¶æ±‡ç‡å·²åŠ è½½';
	                statusElement.style.color = '#28a745';
	                return;
	            }
	            
	            // ä½¿ç”¨ä¼ å…¥çš„é”™è¯¯æ¶ˆæ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤æ¶ˆæ¯
	            const displayMessage = errorMessage || 'å·²è¶…è¿‡æ±‡ç‡æœåŠ¡ API è®¿é—®é™åˆ¶æ¬¡æ•°ï¼Œè¯·ç¨åå†è¯•';
	            statusElement.innerHTML = displayMessage;
	            statusElement.style.color = '#dc3545';
	        }

	        // è·å–çœŸå®æ±‡ç‡
	        async function loadRates({ forceRefresh = false, reason = 'unknown' } = {}) {
	            if (loadRatesInFlight) return loadRatesInFlight;
	            
	            loadRatesInFlight = (async () => {
	            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
	            const statusElement = document.getElementById('apiStatus');
	            if (statusElement) {
	                statusElement.innerHTML = 'æ­£åœ¨åŠ è½½æ±‡ç‡æ•°æ®...';
                statusElement.style.color = '#6c757d';
                statusElement.style.display = 'block';
	            }
	            
	            try {
	                console.log(`loadRates å¼€å§‹ï¼ŒåŸå› : ${reason}, forceRefresh: ${forceRefresh}`);
	                
	                // å¦‚æœæ­£åœ¨é€€é¿ï¼ˆä¾‹å¦‚è¢«é™æµï¼‰ï¼Œå¼ºåˆ¶èµ°ç¼“å­˜ï¼Œé¿å…é›ªä¸ŠåŠ éœœ
	                if (apiStatus.backoffUntil && nowMs() < apiStatus.backoffUntil) {
	                    forceRefresh = false;
	                }
	                
	                const [{ prices: cryptoPrices, source: cryptoSource, ts: cryptoTs }, { fiatData, source: fiatSource, ts: fiatTs }] =
	                    await Promise.all([
		                        (async () => {
		                            try {
		                                const r = await getPresetCryptoPrices({ forceRefresh });
		                                apiStatus.preset = true;
		                                apiStatus.rateLimited = false;
		                                return r;
		                            } catch (e) {
		                                console.warn('é¢„è®¾å¸ç§ä»·æ ¼è·å–å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜:', e);
		                                apiStatus.preset = false;
		                                if (e?.status === 429) {
		                                    apiStatus.rateLimited = true;
		                                    apiStatus.backoffUntil = nowMs() + 10 * 60 * 1000; // 10åˆ†é’Ÿé€€é¿
		                                }
	                                const stale = readCache(CACHE_KEYS.presetCryptoPrices, -1);
	                                if (stale?.data) return { prices: stale.data, source: 'stale-cache', ts: stale.ts };
	                                throw e;
	                            }
	                        })(),
		                        (async () => {
		                            try {
		                                const r = await getFiatRates({ forceRefresh });
		                                apiStatus.exchangerate = true;
		                                apiStatus.rateLimited = false;
		                                return r;
		                            } catch (e) {
		                                console.warn('ExchangeRate è·å–å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜:', e);
		                                apiStatus.exchangerate = false;
		                                if (e?.status === 429) {
		                                    apiStatus.rateLimited = true;
		                                    apiStatus.backoffUntil = nowMs() + 10 * 60 * 1000; // 10åˆ†é’Ÿé€€é¿
		                                }
	                                const stale = readCache(CACHE_KEYS.fiatRates, -1);
	                                if (stale?.data) return { fiatData: stale.data, source: 'stale-cache', ts: stale.ts };
	                                throw e;
	                            }
	                        })()
	                    ]);
	                
	                const currencies = ['CNY', 'JPY', 'KRW', 'SGD', 'AED', 'HKD', 'MYR', 'TWD'];
	                const cryptos = ['BTC', 'ETH', 'SOL', 'BNB', 'OKB'];
	                const products = ['ZHUJIAO', 'KFC', 'IN11', 'IPHONE17', 'FERRARI', 'PORSCHE', 'XIAOMISU7', 'ROLEX', 'MACBOOK'];
	                const productPrices = { 
	                    ZHUJIAO: 20 / fiatData.rates.CNY,       // 20 CNY è½¬æ¢ä¸º USD
	                    KFC: 50 / fiatData.rates.CNY,           // 50 CNY è½¬æ¢ä¸º USD
	                    IN11: 3000 / fiatData.rates.CNY,        // 3000 CNY è½¬æ¢ä¸º USD
                    IPHONE17: 799,                          // 799 USD
                    FERRARI: 1750000 / fiatData.rates.CNY,  // 1,750,000 CNY è½¬æ¢ä¸º USD
                    PORSCHE: 550000 / fiatData.rates.CNY,   // 550,000 CNY è½¬æ¢ä¸º USD
                    XIAOMISU7: 215900 / fiatData.rates.CNY, // 215,900 CNY è½¬æ¢ä¸º USD
                    ROLEX: 56500 / fiatData.rates.CNY,      // 56,500 CNY è½¬æ¢ä¸º USD
                    MACBOOK: 999                            // 999 USD
                };
                
                rates = {};
                
                // æ„å»ºæ±‡ç‡çŸ©é˜µ
                // è·å–è‡ªå®šä¹‰ä»£å¸ç¬¦å·åˆ—è¡¨
                const customTokenSymbols = customTokens ? Array.from(customTokens.keys()) : [];
                const allCurrencies = [...cryptos, ...customTokenSymbols, 'USD', ...currencies, ...products];
                allCurrencies.forEach(from => {
                    rates[from] = {};
                    allCurrencies.forEach(to => {
                        if (from === to) {
                            rates[from][to] = 1;
                        } else if (cryptos.includes(from) && cryptos.includes(to)) {
                            // åŠ å¯†è´§å¸ä¹‹é—´
                            rates[from][to] = cryptoPrices[from] / cryptoPrices[to];
                        } else if (cryptos.includes(from) && to === 'USD') {
                            // åŠ å¯†è´§å¸åˆ°ç¾å…ƒ
                            rates[from][to] = cryptoPrices[from];
                        } else if (from === 'USD' && cryptos.includes(to)) {
                            // ç¾å…ƒåˆ°åŠ å¯†è´§å¸
                            rates[from][to] = 1 / cryptoPrices[to];
                        } else if (cryptos.includes(from) && currencies.includes(to)) {
                            // åŠ å¯†è´§å¸åˆ°å…¶ä»–æ³•å¸
                            rates[from][to] = cryptoPrices[from] * fiatData.rates[to];
                        } else if (currencies.includes(from) && cryptos.includes(to)) {
                            // å…¶ä»–æ³•å¸åˆ°åŠ å¯†è´§å¸
                            rates[from][to] = 1 / (cryptoPrices[to] * fiatData.rates[from]);
                        } else if (customTokens && customTokenSymbols.includes(from) && customTokenSymbols.includes(to)) {
                            // è‡ªå®šä¹‰ä»£å¸ä¹‹é—´
                            const fromPrice = customTokens.get(from).price;
                            const toPrice = customTokens.get(to).price;
                            rates[from][to] = fromPrice / toPrice;
                        } else if (customTokens && customTokenSymbols.includes(from) && to === 'USD') {
                            // è‡ªå®šä¹‰ä»£å¸åˆ°ç¾å…ƒ
                            rates[from][to] = customTokens.get(from).price;
                        } else if (customTokens && from === 'USD' && customTokenSymbols.includes(to)) {
                            // ç¾å…ƒåˆ°è‡ªå®šä¹‰ä»£å¸
                            rates[from][to] = 1 / customTokens.get(to).price;
                        } else if (customTokens && customTokenSymbols.includes(from) && cryptos.includes(to)) {
                            // è‡ªå®šä¹‰ä»£å¸åˆ°é¢„è®¾åŠ å¯†è´§å¸
                            const fromPrice = customTokens.get(from).price;
                            rates[from][to] = fromPrice / cryptoPrices[to];
                        } else if (customTokens && cryptos.includes(from) && customTokenSymbols.includes(to)) {
                            // é¢„è®¾åŠ å¯†è´§å¸åˆ°è‡ªå®šä¹‰ä»£å¸
                            const toPrice = customTokens.get(to).price;
                            rates[from][to] = cryptoPrices[from] / toPrice;
                        } else if (customTokens && customTokenSymbols.includes(from) && currencies.includes(to)) {
                            // è‡ªå®šä¹‰ä»£å¸åˆ°å…¶ä»–æ³•å¸
                            const fromPrice = customTokens.get(from).price;
                            rates[from][to] = fromPrice * fiatData.rates[to];
                        } else if (customTokens && currencies.includes(from) && customTokenSymbols.includes(to)) {
                            // å…¶ä»–æ³•å¸åˆ°è‡ªå®šä¹‰ä»£å¸
                            const toPrice = customTokens.get(to).price;
                            rates[from][to] = 1 / (toPrice * fiatData.rates[from]);
                        } else if (from === 'USD' && currencies.includes(to)) {
                            // ç¾å…ƒåˆ°å…¶ä»–æ³•å¸
                            rates[from][to] = fiatData.rates[to];
                        } else if (currencies.includes(from) && to === 'USD') {
                            // å…¶ä»–æ³•å¸åˆ°ç¾å…ƒ
                            rates[from][to] = 1 / fiatData.rates[from];
                        } else if (currencies.includes(from) && currencies.includes(to)) {
                            // æ³•å¸ä¹‹é—´
                            rates[from][to] = fiatData.rates[to] / fiatData.rates[from];
                        } else if (products.includes(from) && to === 'USD') {
                            // äº§å“åˆ°ç¾å…ƒ (1 iPhone17 = 799 USD)
                            rates[from][to] = productPrices[from];
                        } else if (from === 'USD' && products.includes(to)) {
                            // ç¾å…ƒåˆ°äº§å“ (1 USD = 1/799 iPhone17)
                            rates[from][to] = 1 / productPrices[to];
                        } else if (products.includes(from) && currencies.includes(to)) {
                            // äº§å“åˆ°å…¶ä»–æ³•å¸
                            rates[from][to] = productPrices[from] * fiatData.rates[to];
                        } else if (currencies.includes(from) && products.includes(to)) {
                            // å…¶ä»–æ³•å¸åˆ°äº§å“
                            rates[from][to] = 1 / (productPrices[to] * fiatData.rates[from]);
                        } else if (cryptos.includes(from) && products.includes(to)) {
                            // åŠ å¯†è´§å¸åˆ°äº§å“
                            rates[from][to] = cryptoPrices[from] / productPrices[to];
                        } else if (products.includes(from) && cryptos.includes(to)) {
                            // äº§å“åˆ°åŠ å¯†è´§å¸
                            rates[from][to] = productPrices[from] / cryptoPrices[to];
                        } else if (customTokens && customTokenSymbols.includes(from) && products.includes(to)) {
                            // è‡ªå®šä¹‰ä»£å¸åˆ°äº§å“
                            const fromPrice = customTokens.get(from).price;
                            rates[from][to] = fromPrice / productPrices[to];
                        } else if (customTokens && products.includes(from) && customTokenSymbols.includes(to)) {
                            // äº§å“åˆ°è‡ªå®šä¹‰ä»£å¸
                            const toPrice = customTokens.get(to).price;
                            rates[from][to] = productPrices[from] / toPrice;
                        } else if (products.includes(from) && products.includes(to)) {
                            // äº§å“ä¹‹é—´
                            rates[from][to] = productPrices[from] / productPrices[to];
                        }
                    });
	                });
	                
	                console.log('æ±‡ç‡åŠ è½½æˆåŠŸ:', rates);
	                
	                const parts = [];
	                if (cryptoSource === 'realtime') parts.push('é¢„è®¾å¸ç§ï¼ˆBinance + OKX å®æ—¶ï¼‰');
	                else if (cryptoSource === 'cache') parts.push(`é¢„è®¾å¸ç§ï¼ˆBinance + OKX ç¼“å­˜ ${formatAge(cryptoTs)}ï¼‰`);
	                else if (cryptoSource === 'stale-cache') parts.push(`é¢„è®¾å¸ç§ï¼ˆBinance + OKX æ—§ç¼“å­˜ ${formatAge(cryptoTs)}ï¼‰`);
	                else parts.push(`é¢„è®¾å¸ç§ï¼ˆæœªçŸ¥æ¥æº ${cryptoSource || 'unknown'}ï¼‰`);
	                
		                if (fiatSource === 'realtime') parts.push('ExchangeRate å®æ—¶');
		                else if (fiatSource === 'cache') parts.push(`ExchangeRate ç¼“å­˜ï¼ˆ${formatAge(fiatTs)}ï¼‰`);
		                else parts.push(`ExchangeRate æ—§ç¼“å­˜ï¼ˆ${formatAge(fiatTs)}ï¼‰`);
		                
		                const allRealtime = (cryptoSource === 'realtime') && (fiatSource === 'realtime');
		                const detailMessage = `æ±‡ç‡å·²åŠ è½½ï¼ˆ${parts.join(' + ')}ï¼‰`;
		                console.log(detailMessage);
		                updateApiStatusDisplay({
		                    message: 'æ±‡ç‡å·²åŠ è½½',
		                    color: allRealtime ? '#1d1d1f' : '#6e6e73'
		                });
	                
	                // è®¾ç½®å®šæœŸåˆ·æ–°æ±‡ç‡çŠ¶æ€ï¼ˆæ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼‰
	                if (!window.rateRefreshInterval) {
	                    window.rateRefreshInterval = setInterval(async () => {
	                        try {
	                            await loadRates({ forceRefresh: true, reason: 'interval' });
	                        } catch (error) {
	                            console.log('å®šæœŸåˆ·æ–°å¤±è´¥ï¼Œå°†åœ¨ä¸‹æ¬¡å°è¯•');
	                        }
	                    }, 5 * 60 * 1000); // 5åˆ†é’Ÿ
	                }
		            } catch (error) {
		                console.error('æ±‡ç‡åŠ è½½å¤±è´¥:', error);
		                
		                // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„æç¤ºä¿¡æ¯
		                let errorMessage = '';
	                if (error?.status === 429 || apiStatus.rateLimited) {
	                    errorMessage = 'æ±‡ç‡æœåŠ¡è§¦å‘è®¿é—®é¢‘ç‡é™åˆ¶ï¼Œæ­£åœ¨ä½¿ç”¨ç¼“å­˜æˆ–è¯·ç¨åå†è¯•';
	                } else if (!apiStatus.preset && !apiStatus.exchangerate) {
	                    errorMessage = 'æ±‡ç‡æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼ˆé¢„è®¾å¸ä»·ä¸æ³•å¸æ±‡ç‡å‡å¤±è´¥ï¼‰';
	                } else if (!apiStatus.preset) {
	                    errorMessage = 'é¢„è®¾å¸ç§ä»·æ ¼æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼ˆBinance/OKXï¼‰';
	                } else if (!apiStatus.exchangerate) {
	                    errorMessage = 'ExchangeRate æ³•å¸æ±‡ç‡æœåŠ¡æš‚æ—¶ä¸å¯ç”¨';
	                } else {
	                    errorMessage = 'æ±‡ç‡åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åå†è¯•';
	                }
	                
	                console.error(errorMessage);
	                updateApiStatusDisplay(false, errorMessage);
	                
	                // æ¸…ç©ºæ±‡ç‡ï¼Œè¡¨ç¤ºæœåŠ¡ä¸å¯ç”¨
	                rates = {};
	            }
	            })().finally(() => {
	                loadRatesInFlight = null;
	            });
	            
	            return loadRatesInFlight;
	        }
	        
	        // æ£€æµ‹ localStorage æ˜¯å¦å¯ç”¨
	        function checkLocalStorage() {
	            try {
                const testKey = '__localStorage_test__';
	                localStorage.setItem(testKey, 'test');
	                localStorage.removeItem(testKey);
	                localStorageAvailable = true;
	                console.log('âœ… localStorage å¯ç”¨');
	                return true;
	            } catch (e) {
	                localStorageAvailable = false;
	                console.error('âŒ localStorage ä¸å¯ç”¨:', e);
	                alert('æµè§ˆå™¨çš„ localStorage åŠŸèƒ½ä¸å¯ç”¨ã€‚çŠ¶æ€è®°å¿†åŠŸèƒ½å°†æ— æ³•ä½¿ç”¨ã€‚\n\nå¯èƒ½åŸå› ï¼š\n1. ä½¿ç”¨äº†éšç§/æ— ç—•æ¨¡å¼\n2. æµè§ˆå™¨è®¾ç½®é˜»æ­¢äº†æœ¬åœ°å­˜å‚¨\n3. ä½¿ç”¨ file:// åè®®æ‰“å¼€ï¼ˆè¯·ä½¿ç”¨ HTTP æœåŠ¡å™¨ï¼‰');
	                return false;
	            }
	        }

        // åˆå§‹åŒ–å‡½æ•°
	        function initApp() {
	            console.log('ğŸš€ å¼€å§‹åˆå§‹åŒ–åº”ç”¨...');

	            checkLocalStorage();
	            
	            // å°½æ—©å¯åŠ¨ OKX WebSocketï¼ˆç”¨äº SOL/OKB å®æ—¶ä»·æ ¼ï¼‰
	            startOkxWebSocket();

		            // å…ˆè®¾ç½®äº‹ä»¶ç›‘å¬å™¨
		            setupBasicEventListeners();
		            setupShareImageModalListeners();
		            
		            // åˆå§‹åŒ–è‡ªå®šä¹‰ä¸‹æ‹‰ï¼ˆæ›¿ä»£ç³»ç»Ÿä¸‹æ‹‰èœå•ï¼‰
		            for (let i = 1; i <= 6; i++) {
		                const select = document.getElementById(`currency${i}`);
		                if (select) buildCustomDropdown(select);
		            }

	            // ç„¶åæ¢å¤çŠ¶æ€
	            restoreState();

            // åœ¨é¡µé¢å…³é—­å‰ä¿å­˜çŠ¶æ€
            window.addEventListener('beforeunload', function() {
                saveState();
                console.log('ğŸ”„ é¡µé¢å…³é—­å‰å·²ä¿å­˜çŠ¶æ€');
            });

            // åœ¨é¡µé¢å¤±å»ç„¦ç‚¹æ—¶ä¹Ÿä¿å­˜çŠ¶æ€ï¼ˆç”¨æˆ·åˆ‡æ¢æ ‡ç­¾é¡µï¼‰
            window.addEventListener('blur', function() {
                saveState();
                console.log('ğŸ”„ é¡µé¢å¤±å»ç„¦ç‚¹ï¼Œå·²ä¿å­˜çŠ¶æ€');
            });

            // é¡µé¢åŠ è½½æ—¶è·å–æ±‡ç‡ï¼ŒåŠ è½½å®Œæˆåé‡æ–°è®¡ç®—
            loadRates().then(() => {
            console.log('æ±‡ç‡åŠ è½½å®Œæˆï¼Œå‡†å¤‡è®¾ç½®è½¬æ¢åŠŸèƒ½');
            
            // åˆå§‹åŒ–æ‰€æœ‰selectå…ƒç´ çš„logoæ˜¾ç¤º
            for (let i = 1; i <= 6; i++) {
                const select = document.getElementById(`currency${i}`);
                if (select) {
                    updateSelectDisplay(select);
                }
            }
            
            // APIåŠ è½½å®Œæˆåï¼Œå¦‚æœæœ‰æ•°æ®å°±é‡æ–°è®¡ç®—ä¸€æ¬¡ä»¥è·å¾—æœ€æ–°æ±‡ç‡
            const hasData = Array.from({length: 6}, (_, i) => i + 1).some(i => 
                document.getElementById(`amount${i}`).value.trim() !== ''
            );
            if (hasData) {
                // APIåŠ è½½å®Œæˆåï¼Œä»¥æœ€åè¾“å…¥çš„æ ä½ä¸ºåŸºå‡†é‡æ–°è®¡ç®—
                const lastAmount = document.getElementById(`amount${lastInputField}`).value.trim();
                if (lastAmount !== '') {
                    console.log(`APIåŠ è½½å®Œæˆï¼Œä»¥æ ä½${lastInputField}ä¸ºåŸºå‡†é‡æ–°è®¡ç®—æœ€æ–°æ±‡ç‡`);
                    convert(lastInputField);
                }
            }
        });
        }

        // ç¡®ä¿ DOM åŠ è½½åæ‰§è¡Œåˆå§‹åŒ–
        if (document.readyState === 'loading') {
            // DOM è¿˜åœ¨åŠ è½½ï¼Œç­‰å¾… DOMContentLoaded äº‹ä»¶
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            // DOM å·²ç»åŠ è½½å®Œæˆï¼Œç›´æ¥æ‰§è¡Œ
            initApp();
        }

        // ä¿å­˜çŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨
        function saveState() {
            const state = {};
            for (let i = 1; i <= 6; i++) {
                state[`amount${i}`] = document.getElementById(`amount${i}`).value;
                state[`currency${i}`] = document.getElementById(`currency${i}`).value;

                // ä¿å­˜è‡ªå®šä¹‰ä»£å¸ä¿¡æ¯
                const select = document.getElementById(`currency${i}`);
                const customOption = select ? select.querySelector('option[value="CUSTOM"]') : null;
                if (customOption) {
                    state[`customToken${i}`] = {
                        tokenKey: customOption.getAttribute('data-token-key'),
                        tokenName: customOption.getAttribute('data-token-name'),
                        tokenSymbol: customOption.getAttribute('data-token-symbol'),
                        displayText: customOption.getAttribute('data-display-text'),
                        tokenLogo: customOption.getAttribute('data-token-logo')
                    };
                }
            }
            state.lastInputField = lastInputField; // ä¿å­˜æœ€åè¾“å…¥çš„æ ä½
            state.customTokens = customTokens ? Array.from(customTokens.entries()) : []; // ä¿å­˜è‡ªå®šä¹‰ä»£å¸æ•°æ®
            localStorage.setItem('valueConverterState', JSON.stringify(state));
            console.log('âœ… çŠ¶æ€å·²ä¿å­˜:', state);
        }
        
        // ä»æœ¬åœ°å­˜å‚¨æ¢å¤çŠ¶æ€
        function restoreState() {
            const savedState = localStorage.getItem('valueConverterState');
            console.log('ğŸ” å°è¯•æ¢å¤çŠ¶æ€ï¼ŒlocalStorage å†…å®¹:', savedState);
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    console.log('ğŸ“¦ è§£æåçš„çŠ¶æ€:', state);

                    // æ¢å¤è‡ªå®šä¹‰ä»£å¸æ•°æ®
                    if (state.customTokens && Array.isArray(state.customTokens)) {
                        customTokens = new Map(state.customTokens);
                    }

                    for (let i = 1; i <= 6; i++) {
                        const amountElement = document.getElementById(`amount${i}`);
                        const selectElement = document.getElementById(`currency${i}`);

                        console.log(`ğŸ”§ å¤„ç†ç¬¬ ${i} ä¸ªå­—æ®µ:`, {
                            savedAmount: state[`amount${i}`],
                            savedCurrency: state[`currency${i}`],
                            currentAmount: amountElement ? amountElement.value : 'null',
                            currentCurrency: selectElement ? selectElement.value : 'null'
                        });

                        if (state[`amount${i}`]) {
                            amountElement.value = state[`amount${i}`];
                            console.log(`  âœ… é‡‘é¢å·²æ¢å¤ä¸º: ${state[`amount${i}`]}`);
                        }
                        if (state[`currency${i}`]) {
                            const oldValue = selectElement.value;
                            selectElement.value = state[`currency${i}`];
                            console.log(`  âœ… è´§å¸å·²ä» ${oldValue} æ¢å¤ä¸º: ${selectElement.value}`);

                            // éªŒè¯è®¾ç½®æ˜¯å¦æˆåŠŸ
                            if (selectElement.value !== state[`currency${i}`]) {
                                console.error(`  âŒ è­¦å‘Šï¼šè´§å¸è®¾ç½®å¤±è´¥ï¼å°è¯•è®¾ç½®ä¸º ${state[`currency${i}`]}ï¼Œä½†å®é™…å€¼ä¸º ${selectElement.value}`);
                            }
                        }

                        // æ¢å¤è‡ªå®šä¹‰ä»£å¸é€‰é¡¹çš„å±æ€§
                        if (state[`customToken${i}`]) {
                            const select = document.getElementById(`currency${i}`);
                            const customOption = select ? select.querySelector('option[value="CUSTOM"]') : null;
                            if (customOption) {
                                const tokenInfo = state[`customToken${i}`];
                                customOption.setAttribute('data-token-key', tokenInfo.tokenKey || '');
                                customOption.setAttribute('data-token-name', tokenInfo.tokenName || '');
                                customOption.setAttribute('data-token-symbol', tokenInfo.tokenSymbol || '');
                                customOption.setAttribute('data-display-text', tokenInfo.displayText || '');
                                customOption.setAttribute('data-token-logo', tokenInfo.tokenLogo || '');
                            }
                        }
                    }

                    // æ¢å¤æœ€åè¾“å…¥çš„æ ä½
                    if (state.lastInputField) {
                        lastInputField = state.lastInputField;
                    }

                    // æ¢å¤è‡ªå®šä¹‰ä»£å¸çš„å¤–éƒ¨æ˜¾ç¤º
                    for (let i = 1; i <= 6; i++) {
                        const select = document.getElementById(`currency${i}`);
                        if (select) {
                            updateSelectDisplay(select);
                        }
                    }

                    console.log('âœ… çŠ¶æ€å·²æ¢å¤:', state);
                } catch (error) {
                    console.log('âŒ æ¢å¤çŠ¶æ€å¤±è´¥:', error);
                }
            } else {
                console.log('âš ï¸ æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„çŠ¶æ€');
            }
        }
        
        function convert(sourceIndex) {
            console.log('Convertå‡½æ•°è¢«è°ƒç”¨ï¼ŒsourceIndex:', sourceIndex);
            if (updating) {
                console.log('æ­£åœ¨æ›´æ–°ä¸­ï¼Œè·³è¿‡æœ¬æ¬¡è½¬æ¢');
                return;
            }
            
            // æ£€æŸ¥æ±‡ç‡æœåŠ¡æ˜¯å¦å¯ç”¨
            if (!rates || Object.keys(rates).length === 0) {
                console.error('æ±‡ç‡æœåŠ¡ä¸å¯ç”¨ï¼Œæ— æ³•è¿›è¡Œè½¬æ¢');
                updating = false;
                return;
            }
            
            updating = true;
            
            const sourceAmount = document.getElementById(`amount${sourceIndex}`).value.replace(/,/g, '');
            let sourceCurrency = document.getElementById(`currency${sourceIndex}`).value;
            
            // å¤„ç†è‡ªå®šä¹‰ä»£å¸ï¼šå¦‚æœé€‰æ‹©çš„æ˜¯CUSTOMï¼Œè·å–å®é™…çš„ä»£å¸ç¬¦å·
            if (sourceCurrency === 'CUSTOM') {
                const sourceSelect = document.getElementById(`currency${sourceIndex}`);
                const customOption = sourceSelect.querySelector('option[value="CUSTOM"]');
                const tokenKey = customOption ? customOption.getAttribute('data-token-key') : null;
                if (tokenKey) {
                    sourceCurrency = tokenKey;
                }
            }
            
            console.log('è½¬æ¢å‚æ•° - é‡‘é¢:', sourceAmount, 'è´§å¸:', sourceCurrency);
            console.log('rateså¯¹è±¡å­˜åœ¨:', !!rates, 'åŒ…å«è´§å¸æ•°é‡:', rates ? Object.keys(rates).length : 0);
            
            if (!sourceAmount || sourceAmount === '') {
	            for (let i = 1; i <= 6; i++) {
	                if (i !== sourceIndex) {
                        document.getElementById(`amount${i}`).value = '';
                    }
                }
                updating = false;
                return;
            }
            
            const amount = parseFloat(sourceAmount);
            if (isNaN(amount)) {
                updating = false;
                return;
            }
            
            for (let i = 1; i <= 6; i++) {
                if (i !== sourceIndex) {
                    let targetCurrency = document.getElementById(`currency${i}`).value;
                    
                    // å¤„ç†ç›®æ ‡è´§å¸ä¹Ÿæ˜¯è‡ªå®šä¹‰ä»£å¸çš„æƒ…å†µ
                    if (targetCurrency === 'CUSTOM') {
                        const targetSelect = document.getElementById(`currency${i}`);
                        const customOption = targetSelect.querySelector('option[value="CUSTOM"]');
                        const tokenKey = customOption ? customOption.getAttribute('data-token-key') : null;
                        if (tokenKey) {
                            targetCurrency = tokenKey;
                        }
                    }
                    
                    let result;
                    
	                    if (sourceCurrency === targetCurrency) {
	                        result = amount;
	                    } else if (rates[sourceCurrency] && rates[sourceCurrency][targetCurrency]) {
	                        result = amount * rates[sourceCurrency][targetCurrency];
	                    } else {
	                        result = 0;
	                    }
	                    
	                    document.getElementById(`amount${i}`).value = formatNumberForDisplay(result);
	                }
	            }
            
            updating = false;
        }
        
	        // æ‰€æœ‰è´§å¸çš„logoå’Œæ˜¾ç¤ºæ–‡æœ¬æ˜ å°„
	        const currencyLogos = {
	            // åŠ å¯†è´§å¸ - UI ä½¿ç”¨å›¾ç‰‡ logoï¼ˆæ³¨æ„ï¼šåˆ†äº«å›¾ä»ä½¿ç”¨ emojiï¼Œé¿å… canvas/CORS é—®é¢˜ï¼‰
	            'BTC': { logo: 'https://assets.coingecko.com/coins/images/1/large/bitcoin.png', text: 'BTC', type: 'image' },
	            'ETH': { logo: 'https://assets.coingecko.com/coins/images/279/large/ethereum.png', text: 'ETH', type: 'image' },
	            'SOL': { logo: 'https://assets.coingecko.com/coins/images/4128/large/solana.png', text: 'SOL', type: 'image' },
	            'BNB': { logo: 'https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png', text: 'BNB', type: 'image' },
	            'OKB': { logo: 'https://assets.coingecko.com/coins/images/4463/large/WeChat_Image_20220118095654.png', text: 'OKB', type: 'image' },
            // æ³•å¸ - ä½¿ç”¨emoji
	            'USD': { logo: 'ğŸ‡ºğŸ‡¸', text: 'USD', type: 'emoji' },
	            'CNY': { logo: 'ğŸ‡¨ğŸ‡³', text: 'CNY', type: 'emoji' },
	            'TWD': { logo: 'ğŸ‡¹ğŸ‡¼', text: 'TWD', type: 'emoji' },
	            'HKD': { logo: 'ğŸ‡­ğŸ‡°', text: 'HKD', type: 'emoji' },
	            'JPY': { logo: 'ğŸ‡¯ğŸ‡µ', text: 'JPY', type: 'emoji' },
	            'KRW': { logo: 'ğŸ‡°ğŸ‡·', text: 'KRW', type: 'emoji' },
	            'SGD': { logo: 'ğŸ‡¸ğŸ‡¬', text: 'SGD', type: 'emoji' },
            'AED': { logo: 'ğŸ‡¦ğŸ‡ª', text: 'AED', type: 'emoji' },
            'MYR': { logo: 'ğŸ‡²ğŸ‡¾', text: 'MYR', type: 'emoji' },
            // å®ç‰© - ä½¿ç”¨emoji
            'ZHUJIAO': { logo: 'ğŸš', text: 'çŒªè„šé¥­', type: 'emoji' },
            'KFC': { logo: 'ğŸ—', text: 'KFC', type: 'emoji' },
            'IN11': { logo: 'ğŸ’ƒ', text: 'in11å«©æ¨¡', type: 'emoji' },
            'IPHONE17': { logo: 'ğŸ“±', text: 'iPhone17', type: 'emoji' },
            'MACBOOK': { logo: 'ğŸ’»', text: 'MacBook Air', type: 'emoji' },
            'ROLEX': { logo: 'âŒš', text: 'åŠ³åŠ›å£«', type: 'emoji' },
            'XIAOMISU7': { logo: 'ğŸï¸', text: 'Xiaomi Su7', type: 'emoji' },
            'PORSCHE': { logo: 'ğŸï¸', text: 'Porsche 718', type: 'emoji' },
            'FERRARI': { logo: 'ğŸï¸', text: 'Ferrari Roma', type: 'emoji' }
        };

	        // æ›´æ–°ä¸‹æ‹‰èœå•çš„å¤–éƒ¨æ˜¾ç¤º
	        function updateSelectDisplay(selectElement) {
	            // è‹¥å·²å¯ç”¨è‡ªå®šä¹‰ä¸‹æ‹‰ï¼Œæ”¹ä¸ºæ›´æ–°è‡ªå®šä¹‰è§¦å‘å™¨æ–‡æœ¬ï¼Œä¸å†ä½¿ç”¨è¦†ç›–å±‚æ–¹æ¡ˆ
	            const wrapper = selectElement.parentElement;
	            const dropdown = wrapper ? wrapper.querySelector('.dropdown') : null;
	            if (dropdown) {
	                updateCustomDropdownTrigger(selectElement);
	                return;
	            }

	            const selectedValue = selectElement.value;
	            
	            // å¤„ç†è‡ªå®šä¹‰ä»£å¸
	            const customOption = selectElement.querySelector('option[value="CUSTOM"]');
	            if (selectedValue === 'CUSTOM' && customOption) {
	                const displayText = customOption.getAttribute('data-display-text');
	                const logoUrl = customOption.getAttribute('data-token-logo');
	                
	                if (displayText && logoUrl) {
	                    // UI ä½¿ç”¨å›¾ç‰‡ Logo
	                    createSelectOverlay(selectElement, logoUrl, displayText, 'image');
	                } else {
	                    restoreOriginalDisplay(selectElement);
	                }
	            }
            // å¤„ç†æ‰€æœ‰é¢„è®¾è´§å¸
            else if (currencyLogos[selectedValue]) {
                const currencyData = currencyLogos[selectedValue];
                createSelectOverlay(selectElement, currencyData.logo, currencyData.text, currencyData.type);
            } else {
                restoreOriginalDisplay(selectElement);
            }
        }
        
	        // åˆ›å»ºé€‰æ‹©æ¡†è¦†ç›–å±‚
	        function createSelectOverlay(selectElement, logoUrl, displayText, logoType = 'image') {
	            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„æ˜¾ç¤ºå±‚æ¥è¦†ç›–åŸå§‹çš„selectæ˜¾ç¤º
	            let displayOverlay = selectElement.nextElementSibling;
	            if (!displayOverlay || !displayOverlay.classList.contains('custom-select-display')) {
	                displayOverlay = document.createElement('div');
	                displayOverlay.className = 'custom-select-display';
                
                // è·å–selectå…ƒç´ çš„ç²¾ç¡®ä½ç½®å’Œæ ·å¼
                const selectStyles = window.getComputedStyle(selectElement);
                const isMediaQuery480 = window.matchMedia('(max-width: 480px)').matches;
                const isMediaQuery768 = window.matchMedia('(max-width: 768px)').matches;
                
                // æ ¹æ®åª’ä½“æŸ¥è¯¢è°ƒæ•´æ ·å¼
                let adjustedRightMargin = '45px'; // é»˜è®¤æ‰£é™¤ä¸‹æ‹‰ç®­å¤´çš„å®½åº¦
                
                if (isMediaQuery480) {
                    adjustedRightMargin = '30px'; // ç§»åŠ¨ç«¯ç®­å¤´æ›´å°
                } else if (isMediaQuery768) {
                    adjustedRightMargin = '35px'; // ä¸­ç­‰å±å¹•
                }
                
	                displayOverlay.style.cssText = `
	                    position: absolute;
	                    top: 0;
	                    left: 0;
	                    right: ${adjustedRightMargin};
	                    height: 100%;
	                    pointer-events: none;
	                    z-index: 1;
	                    padding: 0;
	                    margin: 0;
	                    font-size: ${selectStyles.fontSize};
	                    font-family: "PingFang SC";
	                    line-height: ${selectStyles.lineHeight};
	                    color: #333;
	                    background: transparent;
	                    box-sizing: border-box;
	                    display: flex;
	                    align-items: center;
	                    justify-content: flex-start;
	                `;
	                
	                // è¦†ç›–å±‚åº”å½“ç›¸å¯¹ select çš„åŒ…è£…å®¹å™¨å®šä½ï¼ˆé¿å…åœ¨ .field è¿™ä¸ª flex å®¹å™¨å†…é”™ä½ï¼‰
	                const wrapper = selectElement.parentElement;
	                if (wrapper) {
	                    wrapper.style.position = 'relative';
	                    wrapper.insertBefore(displayOverlay, selectElement.nextSibling);
	                } else {
	                    // æç«¯å…œåº•ï¼šä»æ’å›åŸçˆ¶èŠ‚ç‚¹
	                    selectElement.parentNode.style.position = 'relative';
	                    selectElement.parentNode.insertBefore(displayOverlay, selectElement.nextSibling);
	                }
	            }
            
            // æ¸…ç©ºå†…å®¹å¹¶æ·»åŠ Logo + æ–‡æœ¬
            displayOverlay.innerHTML = '';
            
            // åˆ›å»ºå®¹å™¨div
            const contentDiv = document.createElement('div');
            
            // é‡æ–°è·å–å½“å‰çš„åª’ä½“æŸ¥è¯¢çŠ¶æ€å’Œæ ·å¼
            const selectStyles = window.getComputedStyle(selectElement);
            const isMediaQuery480 = window.matchMedia('(max-width: 480px)').matches;
            const isMediaQuery768 = window.matchMedia('(max-width: 768px)').matches;
            
            let paddingLeft = selectStyles.paddingLeft;
            let logoTextGap = '8px';
            let logoSize = '20px';
            let emojiSize = '14px';
            
            if (isMediaQuery480) {
                paddingLeft = '10px'; // åŒ¹é… CSS: padding: 8px 30px 8px 10px
                logoTextGap = '6px'; // ç§»åŠ¨ç«¯å‡å°é—´è·
                logoSize = '18px'; // ç§»åŠ¨ç«¯å‡å°logo
                emojiSize = '12px'; // ç§»åŠ¨ç«¯å‡å°emoji
            } else if (isMediaQuery768) {
                paddingLeft = '12px'; // åŒ¹é… CSS: padding: 10px 35px 10px 12px
                logoTextGap = '7px'; // ä¸­ç­‰å±å¹•å‡å°é—´è·
                logoSize = '19px'; // ä¸­ç­‰å±å¹•ç¨å¾®å‡å°logo
                emojiSize = '13px'; // ä¸­ç­‰å±å¹•ç¨å¾®å‡å°emoji
            }
            
            contentDiv.style.cssText = `
                display: flex;
                align-items: center;
                padding-left: ${paddingLeft};
                height: 100%;
                gap: ${logoTextGap};
            `;
            
            // åˆ›å»ºLogoå…ƒç´ 
            let logoElement;
            if (logoType === 'emoji') {
                logoElement = document.createElement('div');
                logoElement.textContent = logoUrl; // logoUrlå®é™…ä¸Šæ˜¯emojiå­—ç¬¦
                logoElement.style.cssText = `
                    width: ${logoSize};
                    height: ${logoSize};
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-shrink: 0;
                    font-size: ${emojiSize};
                    background: rgba(0,0,0,0.1);
                `;
            } else {
                logoElement = document.createElement('img');
                logoElement.src = logoUrl;
                logoElement.style.cssText = `
                    width: ${logoSize};
                    height: ${logoSize};
                    border-radius: 50%;
                    object-fit: cover;
                    flex-shrink: 0;
                `;
                
                // å¤„ç†å›¾ç‰‡åŠ è½½å¤±è´¥
                logoElement.onerror = function() {
                    logoElement.style.display = 'none';
                    textSpan.textContent = displayText;
                };
            }
            
            // åˆ›å»ºæ–‡æœ¬å…ƒç´ 
            const textSpan = document.createElement('span');
            textSpan.textContent = displayText;
            textSpan.style.cssText = `
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            `;
            
            contentDiv.appendChild(logoElement);
            contentDiv.appendChild(textSpan);
            displayOverlay.appendChild(contentDiv);
            selectElement.style.color = 'transparent';
        }
        
        // æ¢å¤åŸå§‹æ˜¾ç¤º
	        function restoreOriginalDisplay(selectElement) {
            selectElement.style.color = '';
            const displayOverlay = selectElement.nextElementSibling;
            if (displayOverlay && displayOverlay.classList.contains('custom-select-display')) {
                displayOverlay.style.display = 'none';
            }
        }

	        // åŸºç¡€æ¢ç®—åŠŸèƒ½äº‹ä»¶ç›‘å¬å™¨
		        function setupBasicEventListeners() {
	            function formatNumberWithThousands(value) {
	                const raw = String(value ?? '');
	                if (!raw) return '';
	
	                // ä»…ä¿ç•™æ•°å­—ä¸å°æ•°ç‚¹ï¼ˆä¿ç•™ç¬¬ä¸€ä¸ªå°æ•°ç‚¹ï¼‰
	                const cleaned = raw.replace(/[^\d.]/g, '');
	                if (!cleaned) return '';
	
	                const firstDot = cleaned.indexOf('.');
	                const hasDot = firstDot !== -1;
	                const integerPartRaw = hasDot ? cleaned.slice(0, firstDot) : cleaned;
	                const decimalPartRaw = hasDot ? cleaned.slice(firstDot + 1).replace(/\./g, '') : '';
	
	                // å…è®¸ç”¨æˆ·è¾“å…¥ä»¥ "." å¼€å¤´çš„æƒ…å†µ
	                const integerDigits = integerPartRaw.replace(/^0+(?=\d)/, '') || (integerPartRaw === '' ? '' : '0');
	                const groupedInt = integerDigits.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
	
	                if (hasDot) {
	                    return `${groupedInt}${integerPartRaw === '' ? '' : ''}.${decimalPartRaw}`;
	                }
	                return groupedInt;
	            }
	
	            function applyThousandsSeparatorsToInput(inputEl) {
	                const original = inputEl.value;
	                if (!original) return;
	
	                const selStart = inputEl.selectionStart ?? original.length;
	                const leftRaw = original.slice(0, selStart);
	                const leftDigitsCount = leftRaw.replace(/[^\d.]/g, '').length;
	
	                const formatted = formatNumberWithThousands(original);
	                if (formatted === original) return;
	                inputEl.value = formatted;
	
	                // è¿˜åŸå…‰æ ‡ä½ç½®ï¼šä¿æŒâ€œå…‰æ ‡å·¦ä¾§çš„æ•°å­—/å°æ•°ç‚¹å­—ç¬¦æ•°é‡â€ä¸€è‡´
	                let seen = 0;
	                let newPos = formatted.length;
	                for (let i = 0; i < formatted.length; i++) {
	                    const ch = formatted[i];
	                    if ((ch >= '0' && ch <= '9') || ch === '.') seen++;
	                    if (seen >= leftDigitsCount) {
	                        newPos = i + 1;
	                        break;
	                    }
	                }
	                try {
	                    inputEl.setSelectionRange(newPos, newPos);
	                } catch {}
	            }
	
	            for (let i = 1; i <= 6; i++) {
	                // é‡‘é¢è¾“å…¥äº‹ä»¶
	                document.getElementById(`amount${i}`).addEventListener('input', (e) => {
	                    console.log('Input event triggered for amount' + i);
	                    applyThousandsSeparatorsToInput(e.target);
	                    lastInputField = i;
	                    convert(i);
	                    saveState();
	                });
                
                // è´§å¸é€‰æ‹©äº‹ä»¶
                document.getElementById(`currency${i}`).addEventListener('change', function() {
                    console.log('Currency change event triggered for currency' + i);
                    
                    // å¤„ç†è‡ªå®šä¹‰ä»£å¸é€‰æ‹©
                    if (this.value === 'CUSTOM') {
                        currentSelectId = this.id;
                        openCustomTokenModal();
                        return;
                    }
                    
                    // Fallback: æ£€æµ‹æ˜¯å¦æ˜¯é‡å¤é€‰æ‹©CUSTOMçš„æƒ…å†µï¼ˆä¸»è¦ç”¨äºæ‰‹æœºç«¯ï¼‰
                    if (this.value === 'TEMP_CUSTOM_PLACEHOLDER') {
                        // å¦‚æœé€‰æ‹©äº†ä¸´æ—¶å ä½ç¬¦ï¼Œè¯´æ˜ç”¨æˆ·é‡æ–°é€‰æ‹©äº†CUSTOM
                        this.value = 'CUSTOM';
                        currentSelectId = this.id;
                        openCustomTokenModal();
                        return;
                    }
                    
                    // è®°ä½ä¹‹å‰çš„é€‰æ‹©
                    this.setAttribute('data-previous-value', this.value);
                    
                    // æ›´æ–°å¤–éƒ¨æ˜¾ç¤º
                    updateSelectDisplay(this);
                    
                    // è´§å¸é€‰æ‹©å˜æ›´æ—¶ï¼Œä»¥æœ€åè¾“å…¥çš„æ ä½ä¸ºåŸºå‡†é‡æ–°è®¡ç®—
                    convert(lastInputField);
                    saveState();
                });
                
                // å¤„ç†é‡æ–°é€‰æ‹©è‡ªå®šä¹‰ä»£å¸çš„ç‰¹æ®Šæƒ…å†µ
                const selectElement = document.getElementById(`currency${i}`);
                
                // æ¡Œé¢ç«¯ï¼šä½¿ç”¨focusäº‹ä»¶
                selectElement.addEventListener('focus', function() {
                    // å½“è·å¾—ç„¦ç‚¹æ—¶ï¼Œå¦‚æœå½“å‰æ˜¯CUSTOMï¼Œä¸´æ—¶æ”¹ä¸ºä¸€ä¸ªç‰¹æ®Šå€¼
                    if (this.value === 'CUSTOM') {
                        this.setAttribute('data-was-custom', 'true');
                        // ä¸´æ—¶è®¾ä¸ºä¸€ä¸ªä¸å­˜åœ¨çš„å€¼ï¼Œè¿™æ ·å†é€‰CUSTOMæ—¶ä¼šè§¦å‘change
                        this.value = 'TEMP_CUSTOM_PLACEHOLDER';
                    }
                });
                
                // æ‰‹æœºç«¯ï¼šä½¿ç”¨touchstartäº‹ä»¶ä½œä¸ºè¡¥å……
                selectElement.addEventListener('touchstart', function() {
                    // åœ¨æ‰‹æœºç«¯ï¼Œtouchstartå¯èƒ½æ¯”focusæ›´å¯é 
                    if (this.value === 'CUSTOM' && !this.getAttribute('data-was-custom')) {
                        this.setAttribute('data-was-custom', 'true');
                        this.value = 'TEMP_CUSTOM_PLACEHOLDER';
                    }
                });
                
                selectElement.addEventListener('blur', function() {
                    // å¤±å»ç„¦ç‚¹æ—¶ï¼Œå¦‚æœè¿˜æ˜¯ä¸´æ—¶å€¼ï¼Œæ¢å¤ä¸ºCUSTOM
                    if (this.value === 'TEMP_CUSTOM_PLACEHOLDER' && this.getAttribute('data-was-custom') === 'true') {
                        this.value = 'CUSTOM';
                    }
                    this.removeAttribute('data-was-custom');
                    
                    // æ‰‹æœºç«¯ï¼šå¦‚æœå¼¹çª—å·²æ‰“å¼€ï¼Œç¡®ä¿selectå®Œå…¨å¤±å»ç„¦ç‚¹
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    if (isMobile) {
                        const modal = document.getElementById('customTokenModal');
                        if (modal && modal.style.display === 'block') {
                            // å¼ºåˆ¶selectå¤±å»ç„¦ç‚¹
                            this.blur();
                            // ç§»é™¤ä»»ä½•å¯èƒ½çš„ç„¦ç‚¹
                            if (document.activeElement === this) {
                                document.activeElement.blur();
                            }
                        }
                    }
                });
                
                // æ‰‹æœºç«¯é¢å¤–çš„fallbackï¼šç›‘å¬clickäº‹ä»¶
                selectElement.addEventListener('click', function() {
                    // è®°å½•ç‚¹å‡»æ—¶çš„å€¼ï¼Œç”¨äºæ£€æµ‹æ˜¯å¦æ˜¯é‡å¤é€‰æ‹©
                    this.setAttribute('data-click-value', this.value);
                });
                
                // æ£€æµ‹selecté€‰é¡¹å˜åŒ–ï¼ˆé’ˆå¯¹æ‰‹æœºç«¯çš„ç‰¹æ®Šå¤„ç†ï¼‰
                selectElement.addEventListener('input', function() {
                    const clickValue = this.getAttribute('data-click-value');
                    // å¦‚æœç‚¹å‡»å‰æ˜¯CUSTOMï¼Œç°åœ¨é€‰æ‹©çš„ä¹Ÿæ˜¯CUSTOMï¼Œè¯´æ˜æ˜¯é‡å¤é€‰æ‹©
                    if (clickValue === 'CUSTOM' && this.value === 'CUSTOM') {
                        // ç¡®ä¿currentSelectIdè¢«è®¾ç½®å¹¶æ‰“å¼€å¼¹çª—
                        if (!currentSelectId || !document.getElementById('customTokenModal').style.display || document.getElementById('customTokenModal').style.display === 'none') {
                            currentSelectId = this.id;
                            openCustomTokenModal();
                        }
                    }
                });
                
                // å¤„ç†é‡æ–°é€‰æ‹©è‡ªå®šä¹‰ä»£å¸çš„æƒ…å†µ
                // åªåœ¨changeäº‹ä»¶ä¸­å¤„ç†ï¼Œä¸ä½¿ç”¨å…¶ä»–äº‹ä»¶
                // è¿™æ ·é¿å…äº†ä¸‹æ‹‰èœå•æ‰“å¼€æ—¶å°±è§¦å‘å¼¹çª—çš„é—®é¢˜
            }
        }
        
	        // è‡ªå®šä¹‰ä»£å¸åŠŸèƒ½
	        let currentSelectId = null;
	        let customTokens = new Map(); // å­˜å‚¨è‡ªå®šä¹‰ä»£å¸æ•°æ®
	        const tokenSearchSessionCache = new Map(); // æœ¬æ¬¡é¡µé¢ä¼šè¯å†…çš„æœç´¢ç¼“å­˜ï¼ˆé™ä½ CoinGecko æœç´¢é¢‘ç‡ï¼‰

	        // ===== è‡ªå®šä¹‰ä¸‹æ‹‰ï¼ˆæ›¿ä»£ç³»ç»Ÿ selectï¼‰=====
	        function getSelectDisplayInfo(selectElement) {
	            const value = selectElement.value;
	            if (value === 'CUSTOM') {
	                const customOption = selectElement.querySelector('option[value="CUSTOM"]');
	                const displayText = customOption?.getAttribute('data-display-text') || 'è‡ªå®šä¹‰ä»£å¸';
	                const logoUrl = customOption?.getAttribute('data-token-logo');
	                if (logoUrl) return { type: 'image', logo: logoUrl, text: displayText };
	                return { type: 'emoji', logo: 'ğŸª™', text: displayText };
	            }

	            const mapped = currencyLogos?.[value];
	            if (mapped) return { type: mapped.type, logo: mapped.logo, text: mapped.text || value };

	            const opt = selectElement.querySelector(`option[value="${CSS.escape(value)}"]`);
	            return { type: 'none', logo: '', text: (opt?.textContent || value).trim() };
	        }

		        function updateCustomDropdownTrigger(selectElement) {
		            const wrapper = selectElement.parentElement;
		            if (!wrapper) return;
		            const dropdown = wrapper.querySelector('.dropdown');
		            if (!dropdown) return;

		            const { type, logo, text } = getSelectDisplayInfo(selectElement);
		            const logoBox = dropdown.querySelector('.dropdown-logo');
		            const textBox = dropdown.querySelector('.dropdown-text');
		            if (!logoBox || !textBox) return;

		            textBox.textContent = text;
		            logoBox.innerHTML = '';
		            logoBox.classList.toggle('is-emoji', type === 'emoji');
		            logoBox.classList.toggle('is-image', type === 'image');

		            if (type === 'image' && logo) {
		                const img = document.createElement('img');
		                img.src = logo;
		                img.alt = text;
		                img.onerror = () => {
		                    logoBox.classList.remove('is-image');
		                    logoBox.classList.add('is-emoji');
		                    logoBox.innerHTML = `<span class="dropdown-logo-emoji">â€¢</span>`;
		                };
		                logoBox.appendChild(img);
		            } else if (type === 'emoji' && logo) {
		                const span = document.createElement('span');
		                span.className = 'dropdown-logo-emoji';
		                span.textContent = logo;
		                logoBox.appendChild(span);
		            } else {
		                logoBox.classList.add('is-emoji');
		                logoBox.classList.remove('is-image');
		                const span = document.createElement('span');
		                span.className = 'dropdown-logo-emoji';
		                span.textContent = 'â€¢';
		                logoBox.appendChild(span);
		            }

	            // åŒæ­¥é€‰ä¸­æ€
	            dropdown.querySelectorAll('.dropdown-item').forEach((item) => {
	                const v = item.getAttribute('data-value');
	                const selected = v === selectElement.value;
	                item.setAttribute('aria-selected', selected ? 'true' : 'false');
	            });
	        }

	        function closeAllDropdowns(except) {
	            document.querySelectorAll('.dropdown.open').forEach((dd) => {
	                if (except && dd === except) return;
	                dd.classList.remove('open');
	                const trigger = dd.querySelector('.dropdown-trigger');
	                if (trigger) trigger.setAttribute('aria-expanded', 'false');
	                const menu = dd._menu;
	                if (menu) menu.style.display = 'none';
	            });
	        }
	        
	        function positionDropdownMenu(dropdown) {
	            const trigger = dropdown.querySelector('.dropdown-trigger');
	            const menu = dropdown._menu || dropdown.querySelector('.dropdown-menu');
	            if (!trigger || !menu) return;
	            const scroll = menu.querySelector('.dropdown-menu-scroll');
	            
	            // æ‰“å¼€æ—¶èœå•æ˜¯ display:block æ‰èƒ½æµ‹é‡å°ºå¯¸
	            const wasHidden = menu.style.display === '' || menu.style.display === 'none';
	            if (wasHidden) menu.style.display = 'block';
	            menu.style.visibility = 'hidden';
	            
	            const triggerRect = trigger.getBoundingClientRect();
	            const menuRect = menu.getBoundingClientRect();
	            const gap = 12;
	            const margin = 12;
	            
	            // çº¦æŸèŒƒå›´ï¼šä¼˜å…ˆä¿è¯èœå•å®Œå…¨å±•ç¤ºåœ¨é¡µé¢ä¸»å¡ç‰‡ï¼ˆ.containerï¼‰å†…éƒ¨
	            // è‹¥è·å–å¤±è´¥åˆ™é€€å›åˆ°è§†å£èŒƒå›´
	            const containerEl = document.querySelector('.container');
	            const containerRect = containerEl ? containerEl.getBoundingClientRect() : null;
	            const bounds = containerRect
	                ? {
	                        left: containerRect.left,
	                        right: containerRect.right,
	                        top: containerRect.top,
	                        bottom: containerRect.bottom
	                  }
	                : {
	                        left: margin,
	                        right: window.innerWidth - margin,
	                        top: margin,
	                        bottom: window.innerHeight - margin
	                  };
	            
	            // é¢å¤–å…œåº•ï¼šåŒæ—¶ä¸èƒ½è¶…å‡ºè§†å£
	            bounds.left = Math.max(bounds.left, margin);
	            bounds.top = Math.max(bounds.top, margin);
	            bounds.right = Math.min(bounds.right, window.innerWidth - margin);
	            bounds.bottom = Math.min(bounds.bottom, window.innerHeight - margin);
	            
	            // ç›®æ ‡ï¼šç‚¹å‡»ç›®æ ‡æ¡†åï¼Œä»å³ä¾§â€œä¾§å¼¹â€å‡ºç°ï¼Œå¹¶å…è®¸æ»šåŠ¨é€‰æ‹©ã€‚
	            // è§†è§‰ä¸Šæ›´æ¥è¿‘æŠŠåŸæœ¬â€œå‘ä¸‹å¼¹å‡ºâ€æ”¹æˆâ€œå‘å³å¼¹å‡ºâ€ï¼šèœå•ä¸ç›®æ ‡æ¡†å‚ç›´å±…ä¸­å¯¹é½ã€‚
	            let side = 'right';
	            let left = triggerRect.right + gap;
	            let top = triggerRect.top;
	            
	            // å®½åº¦ï¼šç•¥å¤§äºç›®æ ‡æ¡†ï¼Œä½†ä¸è¶…è¿‡å¡ç‰‡/è§†å£
	            let width = Math.max(260, Math.min(360, Math.max(triggerRect.width, menuRect.width || 300)));
	            width = Math.min(width, Math.max(220, bounds.right - bounds.left));
	            
	            if (left + width > bounds.right) {
	                left = triggerRect.left - gap - width;
	                side = 'left';
	            }
	            
	            left = Math.max(bounds.left, Math.min(left, bounds.right - width));
	            
	            // é«˜åº¦ï¼šé™åˆ¶æœ€å¤§é«˜åº¦å¹¶å…è®¸æ»šåŠ¨ï¼›ä¼˜å…ˆä¿è¯ä¸è¶…å‡ºå¡ç‰‡èŒƒå›´
	            const maxHeight = Math.min(680, Math.max(200, bounds.bottom - bounds.top - margin * 2));
	            const desiredHeight = Math.min(menuRect.height || 520, maxHeight);
	            top = triggerRect.top + (triggerRect.height - desiredHeight) / 2;
	            top = Math.max(bounds.top, Math.min(top, bounds.bottom - desiredHeight));
	            // å†å…œåº•ä¸€æ¬¡ï¼Œç¡®ä¿ä¸ä¼šè¶Šå‡ºè§†å£
	            top = Math.max(margin, Math.min(top, window.innerHeight - margin - desiredHeight));
	            
	            // ç®­å¤´ä½ç½®ï¼šæŒ‡å‘è§¦å‘å™¨çš„å‚ç›´ä¸­å¿ƒ
	            const arrowCenterY = triggerRect.top + triggerRect.height / 2;
	            let arrowTop = arrowCenterY - top;
	            arrowTop = Math.max(20, Math.min(arrowTop, desiredHeight - 20));
	            menu.style.setProperty('--arrow-top', `${Math.floor(arrowTop)}px`);
	            menu.setAttribute('data-side', side);
	            
	            menu.style.width = `${Math.floor(width)}px`;
	            menu.style.left = `${Math.floor(left)}px`;
	            menu.style.top = `${Math.floor(top)}px`;
	            if (scroll) scroll.style.maxHeight = `${Math.floor(maxHeight)}px`;
	            menu.style.visibility = '';
	            if (wasHidden) menu.style.display = 'block';
	        }

	        function buildCustomDropdown(selectElement) {
	            const wrapper = selectElement.parentElement;
	            if (!wrapper) return;
	            if (wrapper.querySelector('.dropdown')) return;

	            // éšè—åŸç”Ÿ selectï¼Œä½†ä¿ç•™å…¶äº‹ä»¶/çŠ¶æ€/å­˜å‚¨é€»è¾‘
	            selectElement.classList.add('native-select-hidden');

	            const dropdown = document.createElement('div');
	            dropdown.className = 'dropdown';

	            const trigger = document.createElement('button');
	            trigger.type = 'button';
	            trigger.className = 'dropdown-trigger';
	            trigger.setAttribute('aria-haspopup', 'listbox');
	            trigger.setAttribute('aria-expanded', 'false');

	            trigger.innerHTML = `
	                <span class="dropdown-trigger-left">
	                    <span class="dropdown-logo"></span>
	                    <span class="dropdown-text"></span>
	                </span>
	                <svg class="dropdown-chevron" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                    <path d="M7 10l5 5 5-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
	                </svg>
	            `;

	            const menu = document.createElement('div');
	            menu.className = 'dropdown-menu';
	            menu.setAttribute('role', 'listbox');
	            // å…³é”®ï¼šmenu ä½¿ç”¨ fixed å®šä½æ—¶ï¼Œå¦‚æœåœ¨ transform å®¹å™¨å†…ä¼šå‘ç”Ÿåç§»
	            // å°† menu portal åˆ° bodyï¼Œä¿è¯ fixed ç›¸å¯¹è§†å£å®šä½
	            const scroll = document.createElement('div');
	            scroll.className = 'dropdown-menu-scroll';
	            menu.appendChild(scroll);
	            document.body.appendChild(menu);
	            dropdown._menu = menu;

	            // æ ¹æ® optgroup/option æ„å»ºèœå•
	            const children = Array.from(selectElement.children);
	            for (const child of children) {
	                if (child.tagName === 'OPTGROUP') {
	                    const groupLabel = child.getAttribute('label') || '';
	                    const groupTitle = document.createElement('div');
	                    groupTitle.className = 'dropdown-group';
	                    groupTitle.textContent = groupLabel;
	                    scroll.appendChild(groupTitle);

	                    const opts = Array.from(child.querySelectorAll('option'));
	                    for (const opt of opts) {
	                        const value = opt.value;
	                        if (value === 'TEMP_CUSTOM_PLACEHOLDER') continue;
	                        const item = document.createElement('div');
	                        item.className = 'dropdown-item';
	                        item.setAttribute('role', 'option');
	                        item.setAttribute('data-value', value);
	                        item.setAttribute('aria-selected', value === selectElement.value ? 'true' : 'false');

	                        // æ˜¾ç¤ºå†…å®¹ï¼šä¼˜å…ˆç”¨ currencyLogosï¼ˆå›¾ç‰‡/emojiï¼‰ï¼Œå¦åˆ™ç”¨ option æ–‡æœ¬
	                        let displayText = (opt.textContent || value).trim();
	                        let logoType = 'none';
	                        let logo = '';
	                        if (value === 'CUSTOM') {
	                            displayText = 'è‡ªå®šä¹‰ä»£å¸';
	                            logoType = 'emoji';
	                            logo = 'ğŸ”';
	                        } else if (currencyLogos?.[value]) {
	                            const mapped = currencyLogos[value];
	                            logoType = mapped.type;
	                            logo = mapped.logo;
	                            displayText = mapped.text || value;
	                        }

		                        const logoHtml = (() => {
		                            if (logoType === 'image' && logo) return `<span class="dropdown-logo is-image"><img src="${logo}" alt="${displayText}" onerror="this.remove()"></span>`;
		                            if (logoType === 'emoji' && logo) return `<span class="dropdown-logo is-emoji"><span class="dropdown-logo-emoji">${logo}</span></span>`;
		                            return `<span class="dropdown-logo is-emoji"><span class="dropdown-logo-emoji">â€¢</span></span>`;
		                        })();

	                        item.innerHTML = `${logoHtml}<span class="dropdown-item-text">${displayText}</span>`;

	                        item.addEventListener('click', () => {
	                            closeAllDropdowns();
	                            trigger.setAttribute('aria-expanded', 'false');
	                            selectElement.value = value;
	                            selectElement.dispatchEvent(new Event('change', { bubbles: true }));
	                            updateCustomDropdownTrigger(selectElement);
	                        });

	                        scroll.appendChild(item);
	                    }
	                }
	            }

	            trigger.addEventListener('click', (e) => {
	                e.preventDefault();
	                const willOpen = !dropdown.classList.contains('open');
	                closeAllDropdowns(willOpen ? dropdown : null);
	                dropdown.classList.toggle('open', willOpen);
	                trigger.setAttribute('aria-expanded', willOpen ? 'true' : 'false');
	                if (willOpen) {
	                    menu.style.display = 'block';
	                    positionDropdownMenu(dropdown);
	                } else {
	                    menu.style.display = 'none';
	                }
	            });

	            // ç›‘å¬ select çš„å˜åŒ–ï¼ˆåŒ…æ‹¬ restoreState / è‡ªå®šä¹‰ä»£å¸é€‰æ‹©åçš„æ›´æ–°ï¼‰
	            selectElement.addEventListener('change', () => updateCustomDropdownTrigger(selectElement));

	            dropdown.appendChild(trigger);
	            wrapper.appendChild(dropdown);
	            updateCustomDropdownTrigger(selectElement);
	        }
        
        // åŸºäºå¸‚å€¼æ’åä¼°ç®—ä»·æ ¼çš„å‡½æ•°
        function getEstimatedPrice(coin) {
            // å¦‚æœæ²¡æœ‰å¸‚å€¼æ’åï¼Œç»™ä¸€ä¸ªé»˜è®¤çš„å°ä»·æ ¼
            if (!coin.market_cap_rank) {
                return 0.001; // é»˜è®¤ $0.001
            }
            
            const rank = coin.market_cap_rank;
            
            // åŸºäºå¸‚å€¼æ’åçš„ç²—ç•¥ä»·æ ¼ä¼°ç®—
            if (rank <= 10) return 50; // å‰10åï¼Œå¤§æ¦‚$50
            if (rank <= 50) return 5; // å‰50åï¼Œå¤§æ¦‚$5
            if (rank <= 100) return 1; // å‰100åï¼Œå¤§æ¦‚$1
            if (rank <= 500) return 0.1; // å‰500åï¼Œå¤§æ¦‚$0.1
            if (rank <= 1000) return 0.01; // å‰1000åï¼Œå¤§æ¦‚$0.01
            return 0.001; // å…¶ä»–ï¼Œå¤§æ¦‚$0.001
        }
        
        // æœ¬åœ°å¸¸è§ä»£å¸æ•°æ®åº“
        function getLocalTokenResults(query) {
            const commonTokens = [
                { id: 'dogecoin', name: 'Dogecoin', symbol: 'doge', large: 'https://assets.coingecko.com/coins/images/5/large/dogecoin.png', market_cap_rank: 8 },
                { id: 'cardano', name: 'Cardano', symbol: 'ada', large: 'https://assets.coingecko.com/coins/images/975/large/cardano.png', market_cap_rank: 9 },
                { id: 'polkadot', name: 'Polkadot', symbol: 'dot', large: 'https://assets.coingecko.com/coins/images/12171/large/polkadot.png', market_cap_rank: 12 },
                { id: 'chainlink', name: 'Chainlink', symbol: 'link', large: 'https://assets.coingecko.com/coins/images/877/large/chainlink-new-logo.png', market_cap_rank: 15 },
                { id: 'polygon', name: 'Polygon', symbol: 'matic', large: 'https://assets.coingecko.com/coins/images/4713/large/matic-token-icon.png', market_cap_rank: 16 },
                { id: 'avalanche-2', name: 'Avalanche', symbol: 'avax', large: 'https://assets.coingecko.com/coins/images/12559/large/coin-round-red.png', market_cap_rank: 17 },
                { id: 'shiba-inu', name: 'Shiba Inu', symbol: 'shib', large: 'https://assets.coingecko.com/coins/images/11939/large/shiba.png', market_cap_rank: 18 },
                { id: 'uniswap', name: 'Uniswap', symbol: 'uni', large: 'https://assets.coingecko.com/coins/images/12504/large/uniswap-uni.png', market_cap_rank: 20 },
                { id: 'litecoin', name: 'Litecoin', symbol: 'ltc', large: 'https://assets.coingecko.com/coins/images/2/large/litecoin.png', market_cap_rank: 21 },
                { id: 'near', name: 'NEAR Protocol', symbol: 'near', large: 'https://assets.coingecko.com/coins/images/10365/large/near_icon.png', market_cap_rank: 25 },
                { id: 'aptos', name: 'Aptos', symbol: 'apt', large: 'https://assets.coingecko.com/coins/images/26455/large/aptos_round.png', market_cap_rank: 30 },
                { id: 'arbitrum', name: 'Arbitrum', symbol: 'arb', large: 'https://assets.coingecko.com/coins/images/16547/large/photo_2023-03-29_21.47.00.jpeg', market_cap_rank: 35 },
                { id: 'optimism', name: 'Optimism', symbol: 'op', large: 'https://assets.coingecko.com/coins/images/25244/large/Optimism.png', market_cap_rank: 40 }
            ];
            
            const lowerQuery = query.toLowerCase();
            return commonTokens.filter(token => 
                token.name.toLowerCase().includes(lowerQuery) || 
                token.symbol.toLowerCase().includes(lowerQuery)
            );
        }
        
        // è‡ªå®šä¹‰ä»£å¸çš„äº‹ä»¶ç›‘å¬å·²åˆå¹¶åˆ°ä¸Šé¢çš„currency changeäº‹ä»¶ä¸­
        
        // æ‰“å¼€è‡ªå®šä¹‰ä»£å¸å¼¹çª—
        function openCustomTokenModal() {
            document.getElementById('customTokenModal').style.display = 'block';
            document.getElementById('tokenSearchInput').value = '';
            document.getElementById('searchResults').innerHTML = '';
            setupSearchInputListener(); // è®¾ç½®å›è½¦é”®ç›‘å¬
            
            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // æ‰‹æœºç«¯ï¼šå…ˆå¼ºåˆ¶æ‰€æœ‰selectå¤±å»ç„¦ç‚¹
            if (isMobile) {
                // ç«‹å³å¼ºåˆ¶æ‰€æœ‰selectå…ƒç´ å¤±å»ç„¦ç‚¹
                const allSelects = document.querySelectorAll('select');
                allSelects.forEach(select => {
                    select.blur();
                });
                
                // ç¡®ä¿å½“å‰æ²¡æœ‰ä»»ä½•å…ƒç´ æœ‰ç„¦ç‚¹
                if (document.activeElement && document.activeElement.tagName === 'SELECT') {
                    document.activeElement.blur();
                }
            }
            
            // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†
            if (isMobile) {
                // æ‰‹æœºç«¯ï¼šå»¶é•¿å»¶è¿Ÿå¹¶å¼ºåˆ¶èšç„¦ï¼Œç¡®ä¿selectäº‹ä»¶å®Œå…¨ç»“æŸ
                setTimeout(() => {
                    const searchInput = document.getElementById('tokenSearchInput');
                    if (searchInput) {
                        searchInput.placeholder = 'è¾“å…¥ä»£å¸åç§°æˆ–ç¬¦å·...';
                        
                        // å†æ¬¡ç¡®ä¿æ²¡æœ‰selectå…ƒç´ æœ‰ç„¦ç‚¹
                        const activeElement = document.activeElement;
                        if (activeElement && activeElement.tagName === 'SELECT') {
                            activeElement.blur();
                        }
                        
                        // å¼ºåˆ¶èšç„¦åˆ°æœç´¢è¾“å…¥æ¡†
                        searchInput.focus();
                        
                        // å¤‡é€‰æ–¹æ¡ˆï¼šè§¦å‘ç‚¹å‡»äº‹ä»¶æ¥ç¡®ä¿èšç„¦
                        setTimeout(() => {
                            if (document.activeElement !== searchInput) {
                                searchInput.click();
                                searchInput.focus();
                            }
                        }, 50);
                    }
                }, 600); // æ›´é•¿çš„å»¶è¿Ÿç¡®ä¿æ‰€æœ‰selectç›¸å…³äº‹ä»¶å®Œæˆ
            } else {
                // æ¡Œé¢ç«¯ï¼šæ­£å¸¸å¤„ç†
                setTimeout(() => {
                    const searchInput = document.getElementById('tokenSearchInput');
                    if (searchInput) {
                        searchInput.focus();
                    }
                }, 100);
            }
        }
        
        // å…³é—­è‡ªå®šä¹‰ä»£å¸å¼¹çª—
        function closeCustomTokenModal() {
            document.getElementById('customTokenModal').style.display = 'none';
            
            // å¦‚æœç”¨æˆ·æ²¡æœ‰é€‰æ‹©æ–°ä»£å¸å°±å…³é—­å¼¹çª—ï¼Œä¿æŒå½“å‰çŠ¶æ€
            if (currentSelectId) {
                const currentSelect = document.getElementById(currentSelectId);
                if (currentSelect && currentSelect.value === 'CUSTOM') {
                    const customOption = currentSelect.querySelector('option[value="CUSTOM"]');
                    const hasToken = customOption && customOption.getAttribute('data-token-key');
                    
                    if (!hasToken) {
                        // ç¬¬ä¸€æ¬¡ä½¿ç”¨è‡ªå®šä¹‰ä»£å¸ä½†æ²¡æœ‰é€‰æ‹©ï¼Œæ¢å¤åˆ°ä¹‹å‰çš„é€‰æ‹©
                        const previousValue = currentSelect.getAttribute('data-previous-value');
                        if (previousValue && previousValue !== 'CUSTOM') {
                            currentSelect.value = previousValue;
                        } else {
                            currentSelect.value = 'BTC';
                        }
                    }
                    // å¦‚æœå·²ç»æœ‰ä»£å¸ï¼Œä¿æŒCUSTOMé€‰æ‹©ä¸å˜
                }
            }
            
            currentSelectId = null;
        }
        
        // ç‚¹å‡»å¼¹çª—å¤–éƒ¨å…³é—­
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('customTokenModal');
            if (event.target === modal) {
                closeCustomTokenModal();
            }
        });
        
        // æœç´¢ä»£å¸
	        async function searchTokens() {
	            const query = document.getElementById('tokenSearchInput').value.trim();
	            if (!query) {
	                return;
	            }
	            
	            const queryKey = query.toLowerCase();
	            const cached = tokenSearchSessionCache.get(queryKey);
	            if (cached && nowMs() - cached.ts < 60 * 1000) {
	                displaySearchResults(cached.coins || []);
	                return;
	            }
	            
	            const loadingIndicator = document.getElementById('loadingIndicator');
	            const searchResults = document.getElementById('searchResults');
            
            // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            loadingIndicator.style.display = 'block';
            searchResults.innerHTML = '';
            
	            try {
	                // ä½¿ç”¨CoinGecko APIæœç´¢ä»£å¸
	                let searchUrl = `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(query)}`;
	                console.log('æœç´¢URL:', searchUrl);
	                
	                let response;
	                try {
	                    response = await fetchJsonWithTimeout(searchUrl, {
	                        method: 'GET',
	                        headers: {
	                            'Accept': 'application/json'
	                        }
	                    }, 8000);
	                    
	                    apiStatus.coingecko = true;
	                } catch (corsError) {
	                    console.log('æœç´¢APIç›´æ¥è®¿é—®å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®åº“:', corsError);
	                    apiStatus.coingecko = false;
	                    // ä½¿ç”¨æœ¬åœ°çš„å¸¸è§ä»£å¸æ•°æ®åº“ä½œä¸ºå¤‡ç”¨
	                    const localResults = getLocalTokenResults(query);
	                    response = {
	                        ok: true,
                        json: async () => ({ coins: localResults })
                    };
                }
                
                if (!response.ok) {
                    throw new Error('æœç´¢è¯·æ±‚å¤±è´¥');
                }
	                
	                const data = await response.json();
	                loadingIndicator.style.display = 'none';
	                const coins = data.coins || [];
	                tokenSearchSessionCache.set(queryKey, { ts: nowMs(), coins });
	                displaySearchResults(coins);
	                
	            } catch (error) {
	                console.error('æœç´¢ä»£å¸æ—¶å‡ºé”™:', error);
	                apiStatus.coingecko = false;
	                loadingIndicator.style.display = 'none';
	                searchResults.innerHTML = '<div class="no-results">æœç´¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•</div>';
	            }
	        }
        
        // æ˜¾ç¤ºæœç´¢ç»“æœ
        function displaySearchResults(coins) {
            const searchResults = document.getElementById('searchResults');
            
            if (coins.length === 0) {
                searchResults.innerHTML = '<div class="no-results">æœªæ‰¾åˆ°ç›¸å…³ä»£å¸</div>';
                return;
            }
            
            searchResults.innerHTML = '';
            
            // é™åˆ¶æ˜¾ç¤ºå‰10ä¸ªç»“æœ
            coins.slice(0, 10).forEach(coin => {
                const tokenDiv = document.createElement('div');
                tokenDiv.className = 'token-result';
                tokenDiv.onclick = () => selectCustomToken(coin);
                
                tokenDiv.innerHTML = `
                    <img src="${coin.large || coin.thumb}" alt="${coin.name}" class="token-logo" onerror="this.style.display='none'">
                    <div class="token-content">
                        <div class="token-name-row">
                            <div class="token-name">${coin.name}</div>
                        </div>
                        <div class="token-bottom-row">
                            <div class="token-symbol">${coin.symbol}</div>
                            <div class="token-price">
                                å¸‚å€¼æ’å: ${coin.market_cap_rank || 'N/A'}
                            </div>
                        </div>
                    </div>
                `;
                
                searchResults.appendChild(tokenDiv);
            });
        }
        
        // é€‰æ‹©è‡ªå®šä¹‰ä»£å¸
	        async function selectCustomToken(coin) {
	            const selectId = currentSelectId; // å…ˆä¿å­˜ï¼Œé¿å… closeCustomTokenModal() æŠŠ currentSelectId æ¸…ç©º
	            try {
	                console.log('é€‰æ‹©çš„ä»£å¸:', coin);
	                
	                const tokenPriceCacheKey = `${CACHE_KEYS.coingeckoTokenPrice}:${coin.id}`;
	                const cachedPrice = readCache(tokenPriceCacheKey, 2 * 60 * 1000); // 2åˆ†é’Ÿ
	                
	                let price = 0;
	                let isEstimated = false;
	                
	                if (cachedPrice?.data?.price) {
	                    price = cachedPrice.data.price;
	                    isEstimated = !!cachedPrice.data.isEstimated;
	                    console.log(`ä½¿ç”¨ç¼“å­˜ä»·æ ¼ï¼ˆ${formatAge(cachedPrice.ts)}ï¼‰:`, price);
	                } else {
	                    // è·å–ä»£å¸è¯¦ç»†ä¿¡æ¯å’Œä»·æ ¼ï¼ˆCoinGeckoï¼‰
	                    const priceUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${coin.id}&vs_currencies=usd`;
	                    console.log('è¯·æ±‚ä»·æ ¼URL:', priceUrl);
	                    
	                    let response;
	                    try {
	                        response = await fetchJsonWithTimeout(priceUrl, {
	                            method: 'GET',
	                            headers: { 'Accept': 'application/json' }
	                        }, 8000);
	                        
	                        apiStatus.coingecko = true;
	                    } catch (corsError) {
	                        console.log('ç›´æ¥è®¿é—®å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ:', corsError);
	                        apiStatus.coingecko = false;
	                        
	                        // å¦‚æœç›´æ¥è®¿é—®å¤±è´¥ï¼Œä½¿ç”¨ä¸€ä¸ªå¤‡ç”¨çš„ä»·æ ¼ä¼°ç®—ï¼ˆåŸºäºå¸‚å€¼æ’åï¼‰
	                        const estimatedPrice = getEstimatedPrice(coin);
	                        console.log('ä½¿ç”¨ä¼°ç®—ä»·æ ¼:', estimatedPrice);
	                        response = {
	                            ok: true,
	                            status: 200,
	                            statusText: 'OK',
	                            json: async () => ({ [coin.id]: { usd: estimatedPrice } })
	                        };
	                        isEstimated = true;
	                        console.log('âš ï¸ æ³¨æ„ï¼šæ­£åœ¨ä½¿ç”¨åŸºäºå¸‚å€¼æ’åçš„ä¼°ç®—ä»·æ ¼ï¼Œå¯èƒ½ä¸å¤Ÿå‡†ç¡®');
	                    }
	                    
	                    if (!response.ok) {
	                        console.error('ä»·æ ¼APIè¯·æ±‚å¤±è´¥:', response.status, response.statusText);
	                        throw new Error(`è·å–ä»£å¸ä»·æ ¼å¤±è´¥: ${response.status} ${response.statusText}`);
	                    }
	                    
	                    const priceData = await response.json();
	                    console.log('ä»·æ ¼æ•°æ®:', priceData);
	                    
	                    price = priceData[coin.id]?.usd || 0;
	                    console.log('è§£æå‡ºçš„ä»·æ ¼:', price);
	                    
	                    writeCache(tokenPriceCacheKey, { price, isEstimated });
	                }
	                
	                if (price === 0) {
	                    console.warn('ä»·æ ¼ä¸º0ï¼Œå¯èƒ½æ•°æ®æœ‰è¯¯');
	                }
                
                // å­˜å‚¨è‡ªå®šä¹‰ä»£å¸ä¿¡æ¯
                const tokenKey = coin.symbol.toUpperCase();
                const logoUrl = coin.large || coin.thumb || coin.image;
	                customTokens.set(tokenKey, {
	                    id: coin.id,
	                    name: coin.name,
	                    symbol: coin.symbol,
	                    image: logoUrl,
	                    price: price,
	                    isEstimated: isEstimated || price === getEstimatedPrice(coin) // æ ‡è®°æ˜¯å¦ä¸ºä¼°ç®—ä»·æ ¼
	                });
                
                // ä¸æ·»åŠ åˆ°ä¸‹æ‹‰èœå•ï¼Œåªåœ¨å½“å‰ä¼šè¯ä¸­ä½¿ç”¨
                
                // è®¾ç½®è§¦å‘æœç´¢çš„ä¸‹æ‹‰èœå•ä½¿ç”¨è‡ªå®šä¹‰ä»£å¸
	                if (selectId) {
	                    const currentSelect = document.getElementById(selectId);
	                    if (currentSelect) {
                        // ä¿æŒCUSTOMé€‰é¡¹çš„åŸå§‹æ–‡æœ¬"ğŸ” è‡ªå®šä¹‰ä»£å¸"ï¼Œä½†å­˜å‚¨ä»£å¸ä¿¡æ¯
                        const customOption = currentSelect.querySelector('option[value="CUSTOM"]');
                        if (customOption) {
                            // æ›´æ–°ä»£å¸ä¿¡æ¯ï¼ˆè¦†ç›–ä¹‹å‰çš„é€‰æ‹©ï¼‰
                            customOption.setAttribute('data-token-key', tokenKey);
                            customOption.setAttribute('data-token-name', coin.name);
                            customOption.setAttribute('data-token-symbol', coin.symbol.toUpperCase());
                            customOption.setAttribute('data-token-logo', logoUrl);
                            
                            // è®¾ç½®å¤–éƒ¨æ˜¾ç¤ºçš„æ–‡æœ¬ï¼ˆåªæ˜¾ç¤ºä»£å¸ç¬¦å·ï¼ŒLogoå°†é€šè¿‡CSSæ˜¾ç¤ºï¼‰
                            customOption.setAttribute('data-display-text', coin.symbol.toUpperCase());
                        }
                        currentSelect.value = 'CUSTOM';
                        
                        // è®°ä½è¿™ä¸ªé€‰æ‹©ä½œä¸º"ä¹‹å‰çš„å€¼"
                        currentSelect.setAttribute('data-previous-value', 'CUSTOM');
                        
                        // ç«‹å³æ›´æ–°å¤–éƒ¨æ˜¾ç¤º
                        updateSelectDisplay(currentSelect);
                    }
	                }
	                
	                // é‡ç®—æ±‡ç‡çŸ©é˜µä»¥åŒ…å«æ–°çš„è‡ªå®šä¹‰ä»£å¸
	                // é»˜è®¤ä¸å¼ºåˆ¶åˆ·æ–°åŸºç¡€æ±‡ç‡ï¼ˆé¢„è®¾å¸ä»·/ExchangeRateï¼‰ï¼Œé¿å…çŸ­æ—¶é—´å†…é‡å¤è¯·æ±‚
	                await loadRates({ forceRefresh: false, reason: 'customTokenSelected' });
	                
	                // å…³é—­å¼¹çª—
	                closeCustomTokenModal();
	                
	                // é‡æ–°è®¡ç®—è½¬æ¢
	                if (selectId) {
	                    const selectIndex = parseInt(selectId.replace('currency', ''));
	                    convert(selectIndex);
	                    saveState();
	                }
	                
	            } catch (error) {
	                console.error('é€‰æ‹©ä»£å¸æ—¶å‡ºé”™:', error);
                console.error('é”™è¯¯è¯¦æƒ…:', error.message);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                
	                // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
	                let errorMessage = 'è·å–ä»£å¸ä¿¡æ¯å¤±è´¥';
	                if (apiStatus.rateLimited || error.message.includes('429')) {
	                    errorMessage = 'APIè°ƒç”¨å·²è¾¾é™åˆ¶ï¼Œè¯·ç­‰å¾…å‡ åˆ†é’Ÿåé‡è¯•';
	                } else if (!apiStatus.coingecko) {
	                    errorMessage = 'CoinGecko æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè‡ªå®šä¹‰ä»£å¸åŠŸèƒ½å¯èƒ½å—å½±å“';
	                } else if (error.message.includes('Failed to fetch')) {
	                    errorMessage += 'ï¼šç½‘ç»œè¿æ¥é—®é¢˜ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–ç¨åé‡è¯•';
	                } else if (error.message.includes('403') || error.message.includes('401')) {
	                    errorMessage += 'ï¼šAPIè®¿é—®å—é™';
                } else {
                    errorMessage += `ï¼š${error.message}`;
                }
                
                alert(errorMessage);
            }
        }
        
        // æœç´¢é˜²æŠ–
        let searchTimeout;
        
        // è‡ªåŠ¨æœç´¢ç›‘å¬å™¨ - åœ¨å¼¹çª—æ‰“å¼€æ—¶è®¾ç½®
        function setupSearchInputListener() {
            const input = document.getElementById('tokenSearchInput');
            if (input && !input.hasSearchListener) {
                // æ‰‹æœºç«¯ç‰¹æ®Šå¤„ç†ï¼šæ·»åŠ è§¦æ‘¸å’Œèšç„¦äº‹ä»¶
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                if (isMobile) {
                    // æ‰‹æœºç«¯ï¼šæ·»åŠ è§¦æ‘¸äº‹ä»¶æ¥è§¦å‘èšç„¦
                    input.addEventListener('touchstart', function(e) {
                        e.stopPropagation(); // é˜²æ­¢äº‹ä»¶å†’æ³¡
                        this.focus();
                    });
                    
                    // æ‰‹æœºç«¯ï¼šå½“ç”¨æˆ·ç¬¬ä¸€æ¬¡ç‚¹å‡»è¾“å…¥æ¡†æ—¶è‡ªåŠ¨èšç„¦
                    input.addEventListener('click', function() {
                        this.placeholder = 'è¾“å…¥ä»£å¸åç§°æˆ–ç¬¦å·...';
                        this.focus();
                    });
                }
                
                input.addEventListener('input', function(e) {
                    const query = e.target.value.trim();
                    
                    // æ¸…é™¤ä¹‹å‰çš„æœç´¢å®šæ—¶å™¨
                    if (searchTimeout) {
                        clearTimeout(searchTimeout);
                    }
                    
                    if (query === '') {
                        // å¦‚æœè¾“å…¥ä¸ºç©ºï¼Œæ¸…ç©ºç»“æœ
                        document.getElementById('searchResults').innerHTML = '';
                        document.getElementById('loadingIndicator').style.display = 'none';
                        return;
                    }
                    
                    // è®¾ç½®é˜²æŠ–å»¶è¿Ÿï¼šè¾“å…¥åœæ­¢300æ¯«ç§’åå¼€å§‹æœç´¢
                    searchTimeout = setTimeout(() => {
                        searchTokens();
                    }, 300);
                });
                
                // ä¿ç•™å›è½¦é”®æœç´¢
                input.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        if (searchTimeout) {
                            clearTimeout(searchTimeout);
                        }
                        searchTokens();
                    }
                });
                
                input.hasSearchListener = true;
            }
        }
        
    </script>
    </div>

	    <!-- Toast æç¤º -->
	    <div id="shareToast" class="toast">
	        <div class="toast-icon">âœ…</div>
	        <div class="toast-text"></div>
	    </div>

	    <!-- è‡ªå®šä¹‰ä»£å¸å¼¹çª— -->
	    <div id="customTokenModal" class="modal">
	        <div class="modal-content">
		            <div class="modal-header" style="border-bottom: none;">
		                <h3>è‡ªå®šä¹‰ä»£å¸æœç´¢</h3>
		                <span class="close" onclick="closeCustomTokenModal()">&times;</span>
		            </div>
	            <div class="modal-body">
                <div class="search-container">
	                    <input type="text" id="tokenSearchInput" placeholder="è¾“å…¥ä»£ç¬”åç§°æˆ–ç¬¦å·" />
                </div>
                <div id="searchResults" class="search-results"></div>
                <div id="loadingIndicator" class="loading" style="display: none;">
                    <div class="spinner"></div>
                    <p>æ­£åœ¨æœç´¢ä»£å¸...</p>
                </div>
            </div>
	        </div>
	    </div>

	    <!-- åˆ†äº«å›¾é¢„è§ˆå¼¹çª— -->
	    <div id="shareImageModal" class="modal">
	        <div class="modal-content share-modal-content">
	            <div class="modal-header" style="border-radius: 16px 16px 0 0; border-bottom: none; padding-bottom: 10px;">
	                <h3>åˆ†äº«å›¾é¢„è§ˆ</h3>
	                <span class="close" onclick="closeShareImageModal()">&times;</span>
	            </div>
	            <div class="modal-body">
	                <div class="share-preview">
	                    <img id="shareImagePreview" alt="åˆ†äº«å›¾é¢„è§ˆ" />
	                </div>
	                <div class="share-actions">
	                    <button class="primary" id="copyShareImageBtn">
	                        <span style="display:inline-flex; align-items:center; gap:8px; justify-content:center;">
	                            <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                                <path d="M8 7.5A3.5 3.5 0 0 1 11.5 4h7A3.5 3.5 0 0 1 22 7.5v9A3.5 3.5 0 0 1 18.5 20h-7A3.5 3.5 0 0 1 8 16.5v-9zm3.5-1.5A1.5 1.5 0 0 0 10 7.5v9a1.5 1.5 0 0 0 1.5 1.5h7a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 18.5 6h-7z"/>
	                                <path d="M2 6.5A3.5 3.5 0 0 1 5.5 3h.5a1 1 0 1 1 0 2h-.5A1.5 1.5 0 0 0 4 6.5v9A1.5 1.5 0 0 0 5.5 17H6a1 1 0 1 1 0 2h-.5A3.5 3.5 0 0 1 2 15.5v-9z"/>
	                            </svg>
	                            å¤åˆ¶å›¾ç‰‡
	                        </span>
	                    </button>
	                    <button id="downloadShareImageBtn">
	                        <span style="display:inline-flex; align-items:center; gap:8px; justify-content:center;">
	                            <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
	                                <path d="M12 2.5c.55 0 1 .45 1 1v8.2l2.23-2.23a1 1 0 1 1 1.41 1.42l-3.94 3.94a1 1 0 0 1-1.41 0L7.36 10.9a1 1 0 1 1 1.41-1.42L11 11.7V3.5c0-.55.45-1 1-1z"/>
	                                <path d="M6.5 14c.55 0 1 .45 1 1v2.5c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V15c0-.55.45-1 1-1s1 .45 1 1v2.5c0 1.66-1.34 3-3 3h-7c-1.66 0-3-1.34-3-3V15c0-.55.45-1 1-1z"/>
	                            </svg>
	                            ä¸‹è½½å›¾ç‰‡
	                        </span>
	                    </button>
	                </div>
	            </div>
	        </div>
	    </div>

</body>
</html>
